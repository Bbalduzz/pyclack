# Directory Documentation
Generated on: 2024-12-10 07:14:37
Base directory: C:\Users\edoar\Documents\work\pyclack

## Files Overview

| File | Size | Last Modified | Created |
|------|------|---------------|----------|
| .gitignore | 213.0 B | 2024-12-09 16:42:11 | 2024-12-09 12:36:58 |
| README.md | 11.8 KB | 2024-12-09 14:36:08 | 2024-12-09 12:37:18 |
| __init__.py | 74.0 B | 2024-12-09 13:23:29 | 2024-12-09 07:31:12 |
| core\__init__.py | 420.0 B | 2024-12-09 13:09:29 | 2024-12-09 01:11:30 |
| core\confirm.py | 1.8 KB | 2024-12-09 07:30:41 | 2024-12-09 00:56:08 |
| core\multiselect.py | 3.3 KB | 2024-12-09 07:30:45 | 2024-12-09 01:10:38 |
| core\password.py | 2.3 KB | 2024-12-09 07:30:43 | 2024-12-09 00:52:26 |
| core\prompt.py | 7.6 KB | 2024-12-09 15:22:34 | 2024-12-09 00:57:38 |
| core\select.py | 2.1 KB | 2024-12-09 07:46:00 | 2024-12-09 01:13:18 |
| core\select_key.py | 2.1 KB | 2024-12-09 07:30:47 | 2024-12-09 01:10:42 |
| core\spinner.py | 1.9 KB | 2024-12-09 15:31:34 | 2024-12-09 07:29:58 |
| core\text.py | 2.4 KB | 2024-12-09 07:53:57 | 2024-12-09 00:52:28 |
| directory_docs.md | 77.8 KB | 2024-12-09 15:20:30 | 2024-12-09 15:20:30 |
| dist\pyclack_cli-0.1.0-py3-none-any.whl | 18.4 KB | 2024-12-09 13:48:50 | 2024-12-09 13:48:50 |
| dist\pyclack_cli-0.1.0.tar.gz | 12.5 KB | 2024-12-09 13:48:48 | 2024-12-09 13:48:48 |
| docs.py | 5.2 KB | 2024-12-09 13:57:14 | 2024-12-09 13:54:18 |
| main.py | 2.5 KB | 2024-12-09 13:23:24 | 2024-12-09 01:14:42 |
| prompts\__init__.py | 2.9 KB | 2024-12-09 13:09:55 | 2024-12-09 13:03:27 |
| prompts\confirm.py | 1.7 KB | 2024-12-09 13:08:29 | 2024-12-09 12:56:16 |
| prompts\mutliselect.py | 4.4 KB | 2024-12-09 15:27:43 | 2024-12-09 12:59:11 |
| prompts\password.py | 1.4 KB | 2024-12-09 15:28:10 | 2024-12-09 12:55:42 |
| prompts\select.py | 2.4 KB | 2024-12-09 15:28:40 | 2024-12-09 12:57:22 |
| prompts\spinner.py | 1.4 KB | 2024-12-09 15:32:00 | 2024-12-09 13:02:14 |
| prompts\text.py | 1.8 KB | 2024-12-09 15:32:31 | 2024-12-09 12:54:02 |
| pyclack.egg-info\PKG-INFO | 1.7 KB | 2024-12-09 13:24:42 | 2024-12-09 13:24:42 |
| pyclack.egg-info\SOURCES.txt | 490.0 B | 2024-12-09 13:24:42 | 2024-12-09 13:24:42 |
| pyclack.egg-info\dependency_links.txt | 1.0 B | 2024-12-09 13:24:42 | 2024-12-09 13:24:42 |
| pyclack.egg-info\requires.txt | 62.0 B | 2024-12-09 13:24:42 | 2024-12-09 13:24:42 |
| pyclack.egg-info\top_level.txt | 19.0 B | 2024-12-09 13:24:42 | 2024-12-09 13:24:42 |
| pyclack_cli.egg-info\PKG-INFO | 1.7 KB | 2024-12-09 13:48:48 | 2024-12-09 13:48:48 |
| pyclack_cli.egg-info\SOURCES.txt | 510.0 B | 2024-12-09 13:48:48 | 2024-12-09 13:48:08 |
| pyclack_cli.egg-info\dependency_links.txt | 1.0 B | 2024-12-09 13:48:48 | 2024-12-09 13:48:08 |
| pyclack_cli.egg-info\requires.txt | 62.0 B | 2024-12-09 13:48:48 | 2024-12-09 13:48:08 |
| pyclack_cli.egg-info\top_level.txt | 19.0 B | 2024-12-09 13:48:48 | 2024-12-09 13:48:08 |
| setup.py | 1.1 KB | 2024-12-09 13:47:30 | 2024-12-09 13:14:30 |
| utils\__init__.py | 0.0 B | 2024-12-09 07:30:40 | 2024-12-09 07:30:39 |
| utils\styling.py | 4.2 KB | 2024-12-09 07:29:43 | 2024-12-09 07:29:41 |

## Detailed Contents

### .gitignore
- Size: 213.0 B
- Last Modified: 2024-12-09 16:42:11
- Created: 2024-12-09 12:36:58

#### Content:
```txt
# Python cache files
__pycache__/
*.py[cod]
*$py.class
.pytest_cache/
.coverage
.python-version
.env
.venv
venv/
ENV/

# Distribution/packaging
dist/
build/
*.egg-info/

docs.py
directory_docs.md
```

### README.md
- Size: 11.8 KB
- Last Modified: 2024-12-09 14:36:08
- Created: 2024-12-09 12:37:18

#### Content:
```md
<h1 align="center">
  pyclack
  <br>
  <img width="4%" align="center" src="https://img.shields.io/badge/python-blue" alt="logo">
  <img width="6%" align="center" src="https://img.shields.io/pypi/v/pyclack-cli?style=flat&color=blue" alt="logo">
</h1>


<p align="center">
  <b>Building interactive command line interfaces effortlessly.</b>
</p>

<div align="center">
    <kbd>
      <video width="80%" align="center" src="https://github.com/user-attachments/assets/07b959fb-165e-4419-93ba-74c235a7bc38" alt="demo /prompts">
    </kbd>
</div>

<h1 align="center">
  Documentation
</h1>

`/core`: This is your toolkit for building custom CLIs from scratch. It provides robust, unstyled components that give you complete creative freedom while handling all the complex functionality under the hood.

`/prompts`: Need something ready to use? This package offers a collection of beautifully designed prompts with an intuitive API. Just import and start using them - perfect when you want professional results without the custom styling work.

#### Installation
```cmd
pip install pyclack-cli           # Base installation
pip install pyclack-cli[core]     # Core features
pip install pyclack-cli[prompts]  # Prompts features
pip install pyclack-cli[all]      # Everything
```

## Core Prompt Base Class: `/core`

Low-level components for building custom CLI interfaces.

The `Prompt` class is the foundation for all interactive prompts. It handles keyboard input, rendering, and state management.

```python
from core import Prompt

class Prompt:
    def __init__(
        self,
        render: Callable[['Prompt'], Optional[str]],  # Function to render the prompt
        placeholder: str = '',                        # Placeholder text when empty
        initial_value: Any = None,                    # Starting value
        validate: Optional[Callable[[Any], Optional[str]]] = None,  # Validation function
        debug: bool = False,                          # Enable debug mode
        track_value: bool = True                      # Enable value tracking
    )
```

#### Key Properties:
- `state`: Current prompt state ('initial', 'active', 'cancel', 'submit', 'error')
- `value`: Current value of the prompt
- `error`: Current error message if validation fails

#### Methods:
- `prompt()`: Start the prompt and handle user input
- `handle_key(key: str)`: Process keyboard input
- `render()`: Render the current frame
- `on(event: str, callback: Callable)`: Add event listener
- `emit(event: str, *args)`: Emit an event

### `TextPrompt`
```python
TextPrompt(
    render: Callable[['TextPrompt'], str],        # Render function
    placeholder: str = '',                        # Placeholder text
    default_value: str = '',                      # Default if empty
    initial_value: str = '',                      # Starting value
    validate: Optional[Callable[[str], Optional[str]]] = None,  # Validation
    debug: bool = False                           # Debug mode
)
```
Basic text input component with cursor movement and editing capabilities.

example:
```python
from core import TextPrompt

async def custom_text_prompt():
    def render(prompt):
        return f"Enter text: {prompt.value_with_cursor}"

    prompt = TextPrompt(
        render=render,
        placeholder="Type here...",
        initial_value=""
    )
    result = await prompt.prompt()
```

### `PasswordPrompt`
```python
PasswordPrompt(
    render: Callable[['PasswordPrompt'], Optional[str]],  # Render function
    mask: str = '•',                              # Character for masking
    placeholder: str = '',                        # Placeholder text
    validate: Optional[Callable[[Any], Optional[str]]] = None,  # Validation
    debug: bool = False                           # Debug mode
)
```
Masked input component for secure password entry.

example:
```python
from core import PasswordPrompt

async def custom_password_prompt():
    def render(prompt):
        return f"Password: {prompt.masked}"

    prompt = PasswordPrompt(
        render=render,
        mask="*"
    )
    result = await prompt.prompt()
```

#### `SelectPrompt`
```python
SelectPrompt(
    render: Callable[['SelectPrompt'], str],      # Render function
    options: List[Option],                        # List of selectable options
    initial_value: Any = None,                    # Initially selected value
    validate: Optional[Callable[[Any], Optional[str]]] = None,  # Validation
    debug: bool = False                           # Debug mode
)
```
Single-selection component for choosing from a list of options.

example:
```python
from core import SelectPrompt, Option

async def custom_select_prompt():
    options = [
        Option("apple", "Apple"),
        Option("banana", "Banana")
    ]
    
    def render(prompt):
        return f"Select fruit: {prompt.options[prompt.cursor].label}"

    prompt = SelectPrompt(
        render=render,
        options=options
    )
    result = await prompt.prompt()
```

#### `MultiSelectPrompt`
```python
MultiSelectPrompt(
    render: Callable[['MultiSelectPrompt'], Optional[str]],  # Render function
    options: List[Option],                        # List of selectable options
    initial_values: List[Any] = None,             # Initially selected values
    required: bool = False,                       # Require at least one selection
    cursor_at: Any = None,                        # Initial cursor position
    debug: bool = False                           # Debug mode
)
```
Multiple-selection component for choosing multiple items from a list.

example:
```python
from core import MultiSelectPrompt, Option

async def custom_multiselect_prompt():
    options = [
        Option("red", "Red"),
        Option("blue", "Blue")
    ]
    
    def render(prompt):
        selected = [opt.label for opt in prompt.options if opt.value in prompt.value]
        return f"Selected: {', '.join(selected)}"

    prompt = MultiSelectPrompt(
        render=render,
        options=options
    )
    result = await prompt.prompt()
```

#### `ConfirmPrompt`
```python
ConfirmPrompt(
    render: Callable[['ConfirmPrompt'], Optional[str]],  # Render function
    active: str = 'Yes',                          # Text for true value
    inactive: str = 'No',                         # Text for false value
    initial_value: bool = False,                  # Starting value
    debug: bool = False                           # Debug mode
)
```
Yes/No confirmation component.

example
```python
from core import ConfirmPrompt

async def custom_confirm_prompt():
    def render(prompt):
        return f"Proceed? {prompt.active if prompt.value else prompt.inactive}"

    prompt = ConfirmPrompt(
        render=render,
        active="Yes",
        inactive="No"
    )
    result = await prompt.prompt()
```

#### `Spinner`
```python
Spinner(
    # No initialization parameters
    
    # Methods:
    start(message: str = '')      # Start spinning with message
    stop(message: str = None,     # Stop spinning with final message
         code: int = 0)           # Status code (0=success, 1=cancel, 2=error)
    update(message: str)          # Update spinner message
)
```
Loading indicator for async operations.

example:
```python
from core import Spinner

spinner = Spinner()
spinner.start("Loading...")
# Do some work
spinner.stop("Completed!")
```

## Ready-to-Use Prompts: `/prompts`

Pre-styled, ready-to-use components with a simple API.

#### `text()`
```python
async def text(
    message: str,                                 # Prompt message
    placeholder: str = '',                        # Placeholder text
    default_value: str = '',                      # Default if empty
    initial_value: str = '',                      # Starting value
    validate: Optional[Callable[[str], Optional[str]]] = None  # Validation
) -> Union[str, object]                          # Returns value or CANCEL
```
Styled text input with placeholder support.

example:
```python
from prompts import text

result = await text(
    message="What's your name?",
    placeholder="Enter name",
    initial_value=""
)
```

#### `password()`
```python
async def password(
    message: str,                                 # Prompt message
    mask: str = '•',                             # Masking character
    validate: Optional[Callable[[str], Optional[str]]] = None  # Validation
) -> Union[str, object]                          # Returns value or CANCEL
```
Secure password input with masked characters.

example:
```python
from prompts import password

result = await password(
    message="Enter your password:",
    mask="•"
)
```

### select()
```python
async def select(
    message: str,                                 # Prompt message
    options: List[Option],                        # List of options
    initial_value: Any = None,                    # Initially selected value
    max_items: Optional[int] = None               # Max visible items
) -> Union[Any, object]                          # Returns selected value or CANCEL
```
Styled single-selection menu.

example:
```python
from prompts import select, Option

result = await select(
    message="Choose a fruit:",
    options=[
        Option("apple", "Apple"),
        Option("banana", "Banana")
    ]
)
```

### multiselect()
```python
async def multiselect(
    message: str,                                 # Prompt message
    options: List[Option],                        # List of options
    initial_values: List[Any] = None,             # Initially selected values
    max_items: Optional[int] = None,              # Max visible items
    required: bool = True,                        # Require at least one selection
    cursor_at: Any = None                         # Initial cursor position
) -> Union[List[Any], object]                    # Returns selected values or CANCEL
```
Styled multiple-selection menu with checkboxes.

example:
```python
from prompts import multiselect, Option

result = await multiselect(
    message="Select colors:",
    options=[
        Option("red", "Red"),
        Option("blue", "Blue"),
        Option("green", "Green")
    ]
)
```

### confirm()
```python
async def confirm(
    message: str,                                 # Prompt message
    active: str = "Yes",                          # Text for true value
    inactive: str = "No",                         # Text for false value
    initial_value: bool = True                    # Starting value
) -> Union[bool, object]                         # Returns boolean or CANCEL
```
Styled Yes/No confirmation prompt.

example:
```python
from prompts import confirm

result = await confirm(
    message="Do you want to continue?",
    active="Yes",
    inactive="No"
)
```

### spinner()
### spinner()
```python
# As context manager
async with spinner(
    message: str = '',                            # Spinner message
    options: Optional[Dict] = None                # Styling options
) as spin:
    spin.update("New message")                    # Update message

# As decorator
@with_spinner(message: str = '')
async def my_function():
    pass
```
Styled loading spinner with async context manager support.

example:
```python
from prompts import spinner
import asyncio

async def main():
    async with spinner("Installing dependencies..."):
        await asyncio.sleep(2)
    
    # Or use as decorator
    @with_spinner("Loading...")
    async def long_task():
        await asyncio.sleep(2)
```

### Additional Features

- All prompts support cancellation with Ctrl+C
- Built-in error handling and validation
- Unicode support with fallbacks
- Consistent styling and color themes
- Keyboard navigation (arrow keys, vim-style hjkl)

```

### __init__.py
- Size: 74.0 B
- Last Modified: 2024-12-09 13:23:29
- Created: 2024-12-09 07:31:12

#### Content:
```py
from . import core
from . import prompts

__all__ = ['core', 'prompts']
```

### core\__init__.py
- Size: 420.0 B
- Last Modified: 2024-12-09 13:09:29
- Created: 2024-12-09 01:11:30

#### Content:
```py
from .password import PasswordPrompt
from .text import TextPrompt
from .confirm import ConfirmPrompt
from .select import SelectPrompt
from .multiselect import MultiSelectPrompt, Option
from .select_key import SelectKeyPrompt
from .prompt import is_cancel
from .spinner import Spinner

from typing import Any
from dataclasses import dataclass
@dataclass
class Option:
    value: Any
    label: str = ''
    hint: str = ''
```

### core\confirm.py
- Size: 1.8 KB
- Last Modified: 2024-12-09 07:30:41
- Created: 2024-12-09 00:56:08

#### Content:
```py
from core.prompt import *
from typing import Optional, Callable, Any, Union

class ConfirmPrompt(Prompt):
    def __init__(
        self,
        render: Callable[['ConfirmPrompt'], Optional[str]],
        active: str = 'Yes',
        inactive: str = 'No',
        initial_value: bool = False,
        debug: bool = False
    ):
        super().__init__(
            render=render,
            initial_value=initial_value,
            debug=debug,
            track_value=False  # Important: we're handling value tracking differently for confirm
        )
        
        self.active = active
        self.inactive = inactive
        self.value = initial_value
        
        # Set up event handlers
        self.on('value', self._handle_value)
        self.on('confirm', self._handle_confirm)
        self.on('cursor', self._handle_cursor)
    
    @property
    def cursor(self) -> int:
        return 0 if self.value else 1
    
    @property
    def _value(self) -> bool:
        return self.cursor == 0
    
    def _handle_value(self, *args):
        """Handle value changes."""
        self.value = self._value
    
    def _handle_confirm(self, confirm: bool):
        """Handle confirmation (y/n key press)."""
        sys.stdout.write('\033[A')  # Move cursor up one line
        self.value = confirm
        self.state = 'submit'
        self.close()
    
    def _handle_cursor(self, direction: str):
        """Handle cursor movement (left/right/up/down)."""
        if direction in ('left', 'right', 'up', 'down'):
            self.value = not self.value
    
    def handle_key(self, key: str) -> bool:
        """Override key handling for confirm-specific behavior."""
        if key.lower() in ('y', 'n'):
            self._handle_confirm(key.lower() == 'y')
            return False
        
        return super().handle_key(key)

```

### core\multiselect.py
- Size: 3.3 KB
- Last Modified: 2024-12-09 07:30:45
- Created: 2024-12-09 01:10:38

#### Content:
```py
from core.prompt import *
from core.select import Option
from typing import Any, Generic, TypeVar, List, Optional

T = TypeVar('T')

class MultiSelectPrompt(Prompt, Generic[T]):
    def __init__(
        self,
        render: Callable[['MultiSelectPrompt'], Optional[str]],
        options: List[Option],
        initial_values: List[Any] = None,
        required: bool = False,
        cursor_at: Any = None,
        debug: bool = False
    ):
        super().__init__(
            render=render,
            debug=debug,
            track_value=False  # We handle value tracking ourselves
        )
        
        self.options = options
        self.value = list(initial_values or [])
        self._cursor = max(
            next((i for i, opt in enumerate(options) if opt.value == cursor_at), 0),
            0
        )
        self.required = required
        
        # Set up event handlers
        self.on('key', self._handle_key)
        self.on('cursor', self._handle_cursor)
    
    @property
    def cursor(self) -> int:
        return self._cursor
    
    @cursor.setter
    def cursor(self, value: int):
        self._cursor = value
    
    @property
    def _value(self) -> Any:
        """Get the value at current cursor position."""
        return self.options[self.cursor].value
    
    def toggle_all(self):
        """Toggle all options selection."""
        all_selected = len(self.value) == len(self.options)
        if all_selected:
            self.value = [] if not self.required else [self._value]
        else:
            self.value = [opt.value for opt in self.options]
    
    def toggle_value(self):
        """Toggle current value selection."""
        current = self._value
        if current in self.value:
            # Don't deselect if it's the last item and required is True
            if not (self.required and len(self.value) == 1):
                self.value = [v for v in self.value if v != current]
        else:
            self.value = [*self.value, current]
    
    def _handle_key(self, char: str):
        """Handle key press events."""
        if char == 'a':
            self.toggle_all()
    
    def _handle_cursor(self, key: str):
        """Handle cursor movement and space selection."""
        if key in ('left', 'up'):
            self.cursor = (
                len(self.options) - 1 if self.cursor == 0 
                else self.cursor - 1
            )
        elif key in ('down', 'right'):
            self.cursor = (
                0 if self.cursor == len(self.options) - 1 
                else self.cursor + 1
            )
        elif key == 'space':
            self.toggle_value()
    
    def handle_key(self, key: str) -> bool:
        """Override key handling for multi-select specific behavior."""
        if key == readchar.key.ENTER:
            if self.required and not self.value:
                self.error = "At least one option must be selected"
                self.state = 'error'
                return True
            
            if self.validate:
                problem = self.validate(self.value)
                if problem:
                    self.error = problem
                    self.state = 'error'
                    return True
            
            self.state = 'submit'
            return False
            
        return super().handle_key(key)

```

### core\password.py
- Size: 2.3 KB
- Last Modified: 2024-12-09 07:30:43
- Created: 2024-12-09 00:52:26

#### Content:
```py
from core.prompt import *
from typing import Optional, Callable, Any, Union

class PasswordPrompt(Prompt):
    def __init__(
        self,
        render: Callable[['PasswordPrompt'], Optional[str]],
        mask: str = '•',
        placeholder: str = '',
        validate: Optional[Callable[[Any], Optional[str]]] = None,
        debug: bool = False
    ):
        super().__init__(
            render=render,
            placeholder=placeholder,
            initial_value='',
            validate=validate,
            debug=debug
        )
        
        self._mask = mask
        self.value_with_cursor = ''
        self._text_buffer = []
        
        self.on('finalize', self._handle_finalize)
        self.on('key', self._handle_key)
        
    @property
    def cursor(self) -> int:
        return self._cursor
    
    @property
    def masked(self) -> str:
        """Return the masked version of the value."""
        return self._mask * len(self.value) if self.value else ''
    
    def _handle_finalize(self, *args):
        """Handle the finalize event."""
        self.value_with_cursor = self.masked
    
    def _handle_key(self, char: str):
        """Handle key input events."""
        if char == readchar.key.BACKSPACE:
            if self._cursor > 0:
                self._text_buffer.pop(self._cursor - 1)
                self._cursor -= 1
        elif char.isprintable():
            self._text_buffer.insert(self._cursor, char)
            self._cursor += 1
            
        self.value = ''.join(self._text_buffer)
        self._update_value_with_cursor()
    
    def _update_value_with_cursor(self):
        """Update the value_with_cursor property based on current cursor position."""
        color = Color()
        if self._cursor >= len(self.value):
            self.value_with_cursor = f"{self.masked}{color.inverse(color.hidden('_'))}"
        else:
            s1 = self.masked[:self._cursor]
            s2 = self.masked[self._cursor:]
            self.value_with_cursor = f"{s1}{color.inverse(s2[0])}{s2[1:]}"
    
    async def prompt(self) -> Union[str, object]:
        """Override prompt method to initialize text buffer."""
        self._text_buffer = list(self.initial_value) if self.initial_value else []
        self._cursor = len(self._text_buffer)
        self._update_value_with_cursor()
        return await super().prompt()
```

### core\prompt.py
- Size: 7.6 KB
- Last Modified: 2024-12-09 15:22:34
- Created: 2024-12-09 00:57:38

#### Content:
```py
import sys
import shutil
import readchar
from typing import Any, Callable, Dict, List, Optional, Union

# Constants
CANCEL = object()  # Symbol equivalent
KEYS = {'up', 'down', 'left', 'right', 'space', 'enter'}
ALIASES = {
    'k': 'up',
    'j': 'down',
    'h': 'left',
    'l': 'right'
}

def is_cancel(value: Any) -> bool:
    return value is CANCEL

class Color:
    """Simple color handling class to mimic picocolors functionality."""
    @staticmethod
    def inverse(text: str) -> str:
        return f"\033[7m{text}\033[27m"
    
    @staticmethod
    def hidden(text: str) -> str:
        return f"\033[8m{text}\033[28m"

def wrap_ansi(text: str, width: int, hard: bool = False) -> str:
    """Simple text wrapping implementation."""
    lines = []
    for line in text.split('\n'):
        while len(line) > width:
            if hard:
                lines.append(line[:width])
                line = line[width:]
            else:
                space_index = line[:width].rfind(' ')
                if space_index == -1:
                    space_index = width
                lines.append(line[:space_index])
                line = line[space_index:].lstrip()
        lines.append(line)
    return '\n'.join(lines)

class Prompt:
    def __init__(
        self,
        render: Callable[['Prompt'], Optional[str]],
        placeholder: str = '',
        initial_value: Any = None,
        validate: Optional[Callable[[Any], Optional[str]]] = None,
        debug: bool = False,
        track_value: bool = True
    ):
        self._subscribers: Dict[str, List[dict]] = {}
        self.render_fn = render
        self.placeholder = placeholder
        self.initial_value = initial_value
        self.validate = validate
        self.debug = debug
        self._track = track_value
        
        # State
        self.state = 'initial'  # One of: initial, active, cancel, submit, error
        self.value = initial_value
        self.error = ''
        self._cursor = 0
        self._prev_frame = ''
        self._frame_lines = 0
        self._start_line = 0  # Track where our prompt starts
        
        # Terminal settings
        self.cols = shutil.get_terminal_size().columns

    def _save_cursor_position(self):
        """Save current cursor position."""
        sys.stdout.write('\033[s')

    def _restore_cursor_position(self):
        """Restore saved cursor position."""
        sys.stdout.write('\033[u')

    def _move_to_start(self):
        """Move cursor to start of prompt area."""
        if self._frame_lines > 0:
            sys.stdout.write(f"\033[{self._frame_lines}A")

    def _clear_lines(self, count: int):
        """Clear specified number of lines."""
        for _ in range(count):
            sys.stdout.write('\033[2K')  # Clear line
            sys.stdout.write('\033[1B')  # Move down
        sys.stdout.write(f"\033[{count}A")  # Move back up
    
    def on(self, event: str, callback: Callable[..., Any]) -> None:
        """Add an event listener."""
        if event not in self._subscribers:
            self._subscribers[event] = []
        self._subscribers[event].append({'cb': callback, 'once': False})
    
    def once(self, event: str, callback: Callable[..., Any]) -> None:
        """Add a one-time event listener."""
        if event not in self._subscribers:
            self._subscribers[event] = []
        self._subscribers[event].append({'cb': callback, 'once': True})
    
    def emit(self, event: str, *args: Any) -> None:
        """Emit an event to all listeners."""
        if event not in self._subscribers:
            return
            
        cleanup = []
        for sub in self._subscribers[event]:
            sub['cb'](*args)
            if sub['once']:
                cleanup.append(sub)
                
        for sub in cleanup:
            self._subscribers[event].remove(sub)
    
    def handle_key(self, key: str) -> bool:
        """Handle a keypress. Returns True if should continue, False if should exit."""
        if self.state == 'error':
            self.state = 'active'

        # Special key handling
        if key == readchar.key.CTRL_C:
            self.state = 'cancel'
            return False
            
        elif key == readchar.key.ENTER:
            if self.validate:
                problem = self.validate(self.value)
                if problem:
                    self.error = problem
                    self.state = 'error'
                    return True
            self.state = 'submit'
            return False
            
        # Handle navigation keys
        elif key in (readchar.key.UP, 'k'):
            self.emit('cursor', 'up')
        elif key in (readchar.key.DOWN, 'j'):
            self.emit('cursor', 'down')
        elif key in (readchar.key.LEFT, 'h'):
            self.emit('cursor', 'left')
        elif key in (readchar.key.RIGHT, 'l'):
            self.emit('cursor', 'right')
            
        # Handle regular input
        elif key == ' ':
            self.emit('cursor', 'space')
        elif key in 'yYnN':
            self.emit('confirm', key.lower() == 'y')
        elif key == '\t' and self.placeholder and not self.value:
            self.value = self.placeholder
            self._cursor = len(self.value)
            self.emit('value', self.value)
        
        if key and len(key) == 1:
            self.emit('key', key.lower())
            
        return True

    def render(self) -> None:
        """Render the current frame."""
        frame = wrap_ansi(self.render_fn(self) or '', self.cols, hard=True)
        if frame == self._prev_frame:
            return

        new_lines = frame.count('\n') + 1

        if self.state == 'initial':
            # First render - just write and track position
            sys.stdout.write('\033[?25l')  # Hide cursor
            self._save_cursor_position()  # Save starting position
            sys.stdout.write(frame)
        else:
            # Move to start of prompt area
            self._restore_cursor_position()
            # Clear prompt area
            self._clear_lines(self._frame_lines)
            # Write new frame
            sys.stdout.write(frame)
        
        sys.stdout.flush()
        self._prev_frame = frame
        self._frame_lines = new_lines
        
        if self.state == 'initial':
            self.state = 'active'

    async def prompt(self) -> Union[str, object]:
        """Start the prompt and return the final value."""
        try:
            if self.initial_value is not None and self._track:
                self.value = str(self.initial_value)
                self._cursor = len(self.value)
            
            self.render()
            
            while True:
                try:
                    key = readchar.readkey()
                    if not self.handle_key(key):
                        break
                    self.render()
                except KeyboardInterrupt:
                    self.state = 'cancel'
                    break
            
            # Handle final state
            self._restore_cursor_position()
            self._clear_lines(self._frame_lines)
            if self.state in ('submit', 'cancel'):
                final_frame = self.render_fn(self)
                sys.stdout.write(final_frame)
                sys.stdout.flush()
            
            return self.value if self.state == 'submit' else CANCEL
            
        finally:
            sys.stdout.write('\033[?25h')  # Show cursor
            self.emit(self.state, self.value)
            self._subscribers.clear()

    def close(self) -> None:
        """Clean up and restore terminal settings."""
        sys.stdout.write('\033[?25h')  # Show cursor
```

### core\select.py
- Size: 2.1 KB
- Last Modified: 2024-12-09 07:46:00
- Created: 2024-12-09 01:13:18

#### Content:
```py
from core.prompt import *
from dataclasses import dataclass
from typing import Any, Generic, TypeVar, List, Optional, Callable, TypeVar

T = TypeVar('T')

@dataclass
class Option:
    value: Any
    label: str = ''  # Optional label, will use str(value) if not provided

class SelectPrompt(Prompt):
    def __init__(
        self,
        render: Callable[['SelectPrompt'], str],
        options: List['Option'],
        initial_value: Any = None,
        validate: Optional[Callable[[Any], Optional[str]]] = None,
        debug: bool = False
    ):
        super().__init__(
            render=render,
            validate=validate,
            debug=debug,
            track_value=False
        )
        
        self.options = options
        self._cursor = 0
        
        # Set initial cursor position if initial_value provided
        if initial_value is not None:
            for i, opt in enumerate(options):
                if opt.value == initial_value:
                    self._cursor = i
                    break
        
        self.value = self.options[self._cursor].value
    
    @property
    def cursor(self) -> int:
        return self._cursor
    
    def handle_key(self, key: str) -> bool:
        """Handle keyboard input."""
        if key == readchar.key.CTRL_C:
            self.state = 'cancel'
            return False
            
        elif key == readchar.key.ENTER:
            if self.validate:
                problem = self.validate(self.value)
                if problem:
                    self.error = problem
                    self.state = 'error'
                    return True
            self.state = 'submit'
            return False
            
        # Handle arrow keys
        elif key in (readchar.key.UP, 'k'):
            self._cursor = (self._cursor - 1) % len(self.options)
            self.value = self.options[self._cursor].value
            
        elif key in (readchar.key.DOWN, 'j'):
            self._cursor = (self._cursor + 1) % len(self.options)
            self.value = self.options[self._cursor].value
            
        return True
```

### core\select_key.py
- Size: 2.1 KB
- Last Modified: 2024-12-09 07:30:47
- Created: 2024-12-09 01:10:42

#### Content:
```py
from core.prompt import *
from core.select import Option
from typing import Any, Generic, TypeVar, List, Optional, TypeVar, Callable

T = TypeVar('T')

class SelectKeyPrompt(Prompt, Generic[T]):
    def __init__(
        self,
        render: Callable[['SelectKeyPrompt'], Optional[str]],
        options: List[Option],
        initial_value: Any = None,
        debug: bool = False
    ):
        super().__init__(
            render=render,
            debug=debug,
            track_value=False  # We handle value tracking ourselves
        )
        
        self.options = options
        self._cursor = 0
        
        # Extract the first character of each option value as the key
        self.keys = {
            str(opt.value)[0].lower(): opt.value 
            for opt in options 
            if str(opt.value)
        }
        
        # Set initial cursor position based on initial value
        if initial_value is not None:
            initial_key = str(initial_value)[0].lower()
            self._cursor = max(
                next((i for i, opt in enumerate(options) 
                      if str(opt.value)[0].lower() == initial_key), 0),
                0
            )
        
        # Set up event handler
        self.on('key', self._handle_key)
    
    @property
    def cursor(self) -> int:
        return self._cursor
    
    @cursor.setter
    def cursor(self, value: int):
        self._cursor = value
    
    def _handle_key(self, key: str):
        """Handle key press events."""
        if key not in self.keys:
            return
            
        self.value = self.keys[key]
        self.state = 'submit'
        self.emit('submit')
    
    def handle_key(self, key: str) -> bool:
        """Override key handling for key-select specific behavior."""
        if key == readchar.key.ENTER:
            if self.validate:
                problem = self.validate(self.value)
                if problem:
                    self.error = problem
                    self.state = 'error'
                    return True
                    
            self.state = 'submit'
            return False
            
        return super().handle_key(key)
```

### core\spinner.py
- Size: 1.9 KB
- Last Modified: 2024-12-09 15:31:34
- Created: 2024-12-09 07:29:58

#### Content:
```py
import sys
import threading
import time
from utils.styling import Color, S_BAR, S_STEP_SUBMIT, S_STEP_CANCEL, S_STEP_ERROR, UNICODE

class Spinner:
    """Terminal spinner for loading states."""
    def __init__(self):
        self.frames = ['◒', '◐', '◓', '◑'] if UNICODE else ['•', 'o', 'O', '0']
        self.delay = 0.08 if UNICODE else 0.12
        self.active = False
        self.message = ''
        self._timer = None
        self._frame_index = 0

    def start(self, message: str = ''):
        """Start the spinner with an optional message."""
        self.message = message.rstrip('.')
        self.active = True
        
        def spin():
            while self.active:
                frame = Color.magenta(self.frames[self._frame_index])
                dots = '.' * (1 + (int(time.time() * 8) % 3))
                sys.stdout.write('\r\033[K' + f"{frame}  {self.message}{dots}")
                sys.stdout.flush()
                self._frame_index = (self._frame_index + 1) % len(self.frames)
                time.sleep(self.delay)

        self._timer = threading.Thread(target=spin)
        self._timer.daemon = True
        sys.stdout.write(f"{Color.gray(S_BAR)}\n")
        self._timer.start()

    def stop(self, message: str = None, code: int = 0):
        """Stop the spinner and show final message."""
        self.active = False
        if self._timer:
            self._timer.join()
        
        final_message = message or self.message
        step = (Color.green(S_STEP_SUBMIT) if code == 0 else 
                Color.red(S_STEP_CANCEL) if code == 1 else 
                Color.red(S_STEP_ERROR))
        
        sys.stdout.write('\r\033[K' + f"{step}  {final_message}\n")
        sys.stdout.flush()

    def update(self, message: str):
        """Update the spinner message."""
        self.message = message.rstrip('.')
```

### core\text.py
- Size: 2.4 KB
- Last Modified: 2024-12-09 07:53:57
- Created: 2024-12-09 00:52:28

#### Content:
```py
from core.prompt import *
from utils.styling import Color
from typing import Optional, Callable, Any, Union

class TextPrompt(Prompt):
    def __init__(
        self,
        render: Callable[['TextPrompt'], str],
        placeholder: str = '',
        default_value: str = '',
        initial_value: str = '',
        validate: Optional[Callable[[str], Optional[str]]] = None,
        debug: bool = False
    ):
        super().__init__(
            render=render,
            placeholder=placeholder,
            initial_value=initial_value,
            validate=validate,
            debug=debug
        )
        
        self.default_value = default_value
        self.value_with_cursor = ''
        self._text_buffer = list(initial_value) if initial_value else []
        
        # Set up event handlers
        self.on('finalize', self._handle_finalize)
        self.on('key', self._handle_key)
        self._cursor = len(self._text_buffer)
        
    @property
    def cursor(self) -> int:
        return self._cursor
    
    def _handle_finalize(self, *args):
        """Handle the finalize event."""
        if not self.value and self.default_value:
            self.value = self.default_value
        self.value_with_cursor = self.value
    
    def _handle_key(self, char: str):
        """Handle key input events."""
        if char == readchar.key.BACKSPACE:
            if self._cursor > 0:
                self._text_buffer.pop(self._cursor - 1)
                self._cursor -= 1
        elif char.isprintable():
            self._text_buffer.insert(self._cursor, char)
            self._cursor += 1
            
        self.value = ''.join(self._text_buffer)
        self._update_value_with_cursor()
    
    def _update_value_with_cursor(self):
        """Update the value_with_cursor property based on current cursor position."""
        if self._cursor >= len(self.value):
            self.value_with_cursor = f"{self.value}{Color.inverse(Color.hidden('_'))}"
        else:
            s1 = self.value[:self._cursor]
            s2 = self.value[self._cursor:]
            self.value_with_cursor = f"{s1}{Color.inverse(s2[0])}{s2[1:]}"
    
    async def prompt(self) -> str:
        """Start the prompt and handle initial setup."""
        self._text_buffer = list(self.initial_value) if self.initial_value else []
        self._cursor = len(self._text_buffer)
        self._update_value_with_cursor()
        return await super().prompt()
```

### directory_docs.md
- Size: 77.8 KB
- Last Modified: 2024-12-09 15:20:30
- Created: 2024-12-09 15:20:30

#### Content:
```md
# Directory Documentation
Generated on: 2024-12-09 15:20:30
Base directory: C:\Users\edoar\Documents\work\pyclack

## Files Overview

| File | Size | Last Modified | Created |
|------|------|---------------|----------|
| .gitignore | 194.0 B | 2024-12-09 13:54:26 | 2024-12-09 12:36:58 |
| README.md | 11.8 KB | 2024-12-09 14:36:08 | 2024-12-09 12:37:18 |
| __init__.py | 74.0 B | 2024-12-09 13:23:29 | 2024-12-09 07:31:12 |
| core\__init__.py | 420.0 B | 2024-12-09 13:09:29 | 2024-12-09 01:11:30 |
| core\confirm.py | 1.8 KB | 2024-12-09 07:30:41 | 2024-12-09 00:56:08 |
| core\multiselect.py | 3.3 KB | 2024-12-09 07:30:45 | 2024-12-09 01:10:38 |
| core\password.py | 2.3 KB | 2024-12-09 07:30:43 | 2024-12-09 00:52:26 |
| core\prompt.py | 7.4 KB | 2024-12-09 13:23:56 | 2024-12-09 00:57:38 |
| core\select.py | 2.1 KB | 2024-12-09 07:46:00 | 2024-12-09 01:13:18 |
| core\select_key.py | 2.1 KB | 2024-12-09 07:30:47 | 2024-12-09 01:10:42 |
| core\spinner.py | 1.9 KB | 2024-12-09 12:29:24 | 2024-12-09 07:29:58 |
| core\text.py | 2.4 KB | 2024-12-09 07:53:57 | 2024-12-09 00:52:28 |
| dist\pyclack_cli-0.1.0-py3-none-any.whl | 18.4 KB | 2024-12-09 13:48:50 | 2024-12-09 13:48:50 |
| dist\pyclack_cli-0.1.0.tar.gz | 12.5 KB | 2024-12-09 13:48:48 | 2024-12-09 13:48:48 |
| docs.py | 5.2 KB | 2024-12-09 13:57:14 | 2024-12-09 13:54:18 |
| main.py | 2.5 KB | 2024-12-09 13:23:24 | 2024-12-09 01:14:42 |
| prompts\__init__.py | 2.9 KB | 2024-12-09 13:09:55 | 2024-12-09 13:03:27 |
| prompts\confirm.py | 1.7 KB | 2024-12-09 13:08:29 | 2024-12-09 12:56:16 |
| prompts\mutliselect.py | 4.2 KB | 2024-12-09 13:09:38 | 2024-12-09 12:59:11 |
| prompts\password.py | 1.4 KB | 2024-12-09 12:55:54 | 2024-12-09 12:55:42 |
| prompts\select.py | 2.1 KB | 2024-12-09 13:09:48 | 2024-12-09 12:57:22 |
| prompts\spinner.py | 1.4 KB | 2024-12-09 13:03:00 | 2024-12-09 13:02:14 |
| prompts\text.py | 1.8 KB | 2024-12-09 13:05:32 | 2024-12-09 12:54:02 |
| pyclack.egg-info\PKG-INFO | 1.7 KB | 2024-12-09 13:24:42 | 2024-12-09 13:24:42 |
| pyclack.egg-info\SOURCES.txt | 490.0 B | 2024-12-09 13:24:42 | 2024-12-09 13:24:42 |
| pyclack.egg-info\dependency_links.txt | 1.0 B | 2024-12-09 13:24:42 | 2024-12-09 13:24:42 |
| pyclack.egg-info\requires.txt | 62.0 B | 2024-12-09 13:24:42 | 2024-12-09 13:24:42 |
| pyclack.egg-info\top_level.txt | 19.0 B | 2024-12-09 13:24:42 | 2024-12-09 13:24:42 |
| pyclack_cli.egg-info\PKG-INFO | 1.7 KB | 2024-12-09 13:48:48 | 2024-12-09 13:48:48 |
| pyclack_cli.egg-info\SOURCES.txt | 510.0 B | 2024-12-09 13:48:48 | 2024-12-09 13:48:08 |
| pyclack_cli.egg-info\dependency_links.txt | 1.0 B | 2024-12-09 13:48:48 | 2024-12-09 13:48:08 |
| pyclack_cli.egg-info\requires.txt | 62.0 B | 2024-12-09 13:48:48 | 2024-12-09 13:48:08 |
| pyclack_cli.egg-info\top_level.txt | 19.0 B | 2024-12-09 13:48:48 | 2024-12-09 13:48:08 |
| setup.py | 1.1 KB | 2024-12-09 13:47:30 | 2024-12-09 13:14:30 |
| utils\__init__.py | 0.0 B | 2024-12-09 07:30:40 | 2024-12-09 07:30:39 |
| utils\styling.py | 4.2 KB | 2024-12-09 07:29:43 | 2024-12-09 07:29:41 |

## Detailed Contents

### .gitignore
- Size: 194.0 B
- Last Modified: 2024-12-09 13:54:26
- Created: 2024-12-09 12:36:58

#### Content:
```txt
# Python cache files
__pycache__/
*.py[cod]
*$py.class
.pytest_cache/
.coverage
.python-version
.env
.venv
venv/
ENV/

# Distribution/packaging
dist/
build/
*.egg-info/

docs.py
```

### README.md
- Size: 11.8 KB
- Last Modified: 2024-12-09 14:36:08
- Created: 2024-12-09 12:37:18

#### Content:
```md
<h1 align="center">
  pyclack
  <br>
  <img width="4%" align="center" src="https://img.shields.io/badge/python-blue" alt="logo">
  <img width="6%" align="center" src="https://img.shields.io/pypi/v/pyclack-cli?style=flat&color=blue" alt="logo">
</h1>


<p align="center">
  <b>Building interactive command line interfaces effortlessly.</b>
</p>

<div align="center">
    <kbd>
      <video width="80%" align="center" src="https://github.com/user-attachments/assets/07b959fb-165e-4419-93ba-74c235a7bc38" alt="demo /prompts">
    </kbd>
</div>

<h1 align="center">
  Documentation
</h1>

`/core`: This is your toolkit for building custom CLIs from scratch. It provides robust, unstyled components that give you complete creative freedom while handling all the complex functionality under the hood.

`/prompts`: Need something ready to use? This package offers a collection of beautifully designed prompts with an intuitive API. Just import and start using them - perfect when you want professional results without the custom styling work.

#### Installation
```cmd
pip install pyclack-cli           # Base installation
pip install pyclack-cli[core]     # Core features
pip install pyclack-cli[prompts]  # Prompts features
pip install pyclack-cli[all]      # Everything
```

## Core Prompt Base Class: `/core`

Low-level components for building custom CLI interfaces.

The `Prompt` class is the foundation for all interactive prompts. It handles keyboard input, rendering, and state management.

```python
from core import Prompt

class Prompt:
    def __init__(
        self,
        render: Callable[['Prompt'], Optional[str]],  # Function to render the prompt
        placeholder: str = '',                        # Placeholder text when empty
        initial_value: Any = None,                    # Starting value
        validate: Optional[Callable[[Any], Optional[str]]] = None,  # Validation function
        debug: bool = False,                          # Enable debug mode
        track_value: bool = True                      # Enable value tracking
    )
```

#### Key Properties:
- `state`: Current prompt state ('initial', 'active', 'cancel', 'submit', 'error')
- `value`: Current value of the prompt
- `error`: Current error message if validation fails

#### Methods:
- `prompt()`: Start the prompt and handle user input
- `handle_key(key: str)`: Process keyboard input
- `render()`: Render the current frame
- `on(event: str, callback: Callable)`: Add event listener
- `emit(event: str, *args)`: Emit an event

### `TextPrompt`
```python
TextPrompt(
    render: Callable[['TextPrompt'], str],        # Render function
    placeholder: str = '',                        # Placeholder text
    default_value: str = '',                      # Default if empty
    initial_value: str = '',                      # Starting value
    validate: Optional[Callable[[str], Optional[str]]] = None,  # Validation
    debug: bool = False                           # Debug mode
)
```
Basic text input component with cursor movement and editing capabilities.

example:
```python
from core import TextPrompt

async def custom_text_prompt():
    def render(prompt):
        return f"Enter text: {prompt.value_with_cursor}"

    prompt = TextPrompt(
        render=render,
        placeholder="Type here...",
        initial_value=""
    )
    result = await prompt.prompt()
```

### `PasswordPrompt`
```python
PasswordPrompt(
    render: Callable[['PasswordPrompt'], Optional[str]],  # Render function
    mask: str = '•',                              # Character for masking
    placeholder: str = '',                        # Placeholder text
    validate: Optional[Callable[[Any], Optional[str]]] = None,  # Validation
    debug: bool = False                           # Debug mode
)
```
Masked input component for secure password entry.

example:
```python
from core import PasswordPrompt

async def custom_password_prompt():
    def render(prompt):
        return f"Password: {prompt.masked}"

    prompt = PasswordPrompt(
        render=render,
        mask="*"
    )
    result = await prompt.prompt()
```

#### `SelectPrompt`
```python
SelectPrompt(
    render: Callable[['SelectPrompt'], str],      # Render function
    options: List[Option],                        # List of selectable options
    initial_value: Any = None,                    # Initially selected value
    validate: Optional[Callable[[Any], Optional[str]]] = None,  # Validation
    debug: bool = False                           # Debug mode
)
```
Single-selection component for choosing from a list of options.

example:
```python
from core import SelectPrompt, Option

async def custom_select_prompt():
    options = [
        Option("apple", "Apple"),
        Option("banana", "Banana")
    ]
    
    def render(prompt):
        return f"Select fruit: {prompt.options[prompt.cursor].label}"

    prompt = SelectPrompt(
        render=render,
        options=options
    )
    result = await prompt.prompt()
```

#### `MultiSelectPrompt`
```python
MultiSelectPrompt(
    render: Callable[['MultiSelectPrompt'], Optional[str]],  # Render function
    options: List[Option],                        # List of selectable options
    initial_values: List[Any] = None,             # Initially selected values
    required: bool = False,                       # Require at least one selection
    cursor_at: Any = None,                        # Initial cursor position
    debug: bool = False                           # Debug mode
)
```
Multiple-selection component for choosing multiple items from a list.

example:
```python
from core import MultiSelectPrompt, Option

async def custom_multiselect_prompt():
    options = [
        Option("red", "Red"),
        Option("blue", "Blue")
    ]
    
    def render(prompt):
        selected = [opt.label for opt in prompt.options if opt.value in prompt.value]
        return f"Selected: {', '.join(selected)}"

    prompt = MultiSelectPrompt(
        render=render,
        options=options
    )
    result = await prompt.prompt()
```

#### `ConfirmPrompt`
```python
ConfirmPrompt(
    render: Callable[['ConfirmPrompt'], Optional[str]],  # Render function
    active: str = 'Yes',                          # Text for true value
    inactive: str = 'No',                         # Text for false value
    initial_value: bool = False,                  # Starting value
    debug: bool = False                           # Debug mode
)
```
Yes/No confirmation component.

example
```python
from core import ConfirmPrompt

async def custom_confirm_prompt():
    def render(prompt):
        return f"Proceed? {prompt.active if prompt.value else prompt.inactive}"

    prompt = ConfirmPrompt(
        render=render,
        active="Yes",
        inactive="No"
    )
    result = await prompt.prompt()
```

#### `Spinner`
```python
Spinner(
    # No initialization parameters
    
    # Methods:
    start(message: str = '')      # Start spinning with message
    stop(message: str = None,     # Stop spinning with final message
         code: int = 0)           # Status code (0=success, 1=cancel, 2=error)
    update(message: str)          # Update spinner message
)
```
Loading indicator for async operations.

example:
```python
from core import Spinner

spinner = Spinner()
spinner.start("Loading...")
# Do some work
spinner.stop("Completed!")
```

## Ready-to-Use Prompts: `/prompts`

Pre-styled, ready-to-use components with a simple API.

#### `text()`
```python
async def text(
    message: str,                                 # Prompt message
    placeholder: str = '',                        # Placeholder text
    default_value: str = '',                      # Default if empty
    initial_value: str = '',                      # Starting value
    validate: Optional[Callable[[str], Optional[str]]] = None  # Validation
) -> Union[str, object]                          # Returns value or CANCEL
```
Styled text input with placeholder support.

example:
```python
from prompts import text

result = await text(
    message="What's your name?",
    placeholder="Enter name",
    initial_value=""
)
```

#### `password()`
```python
async def password(
    message: str,                                 # Prompt message
    mask: str = '•',                             # Masking character
    validate: Optional[Callable[[str], Optional[str]]] = None  # Validation
) -> Union[str, object]                          # Returns value or CANCEL
```
Secure password input with masked characters.

example:
```python
from prompts import password

result = await password(
    message="Enter your password:",
    mask="•"
)
```

### select()
```python
async def select(
    message: str,                                 # Prompt message
    options: List[Option],                        # List of options
    initial_value: Any = None,                    # Initially selected value
    max_items: Optional[int] = None               # Max visible items
) -> Union[Any, object]                          # Returns selected value or CANCEL
```
Styled single-selection menu.

example:
```python
from prompts import select, Option

result = await select(
    message="Choose a fruit:",
    options=[
        Option("apple", "Apple"),
        Option("banana", "Banana")
    ]
)
```

### multiselect()
```python
async def multiselect(
    message: str,                                 # Prompt message
    options: List[Option],                        # List of options
    initial_values: List[Any] = None,             # Initially selected values
    max_items: Optional[int] = None,              # Max visible items
    required: bool = True,                        # Require at least one selection
    cursor_at: Any = None                         # Initial cursor position
) -> Union[List[Any], object]                    # Returns selected values or CANCEL
```
Styled multiple-selection menu with checkboxes.

example:
```python
from prompts import multiselect, Option

result = await multiselect(
    message="Select colors:",
    options=[
        Option("red", "Red"),
        Option("blue", "Blue"),
        Option("green", "Green")
    ]
)
```

### confirm()
```python
async def confirm(
    message: str,                                 # Prompt message
    active: str = "Yes",                          # Text for true value
    inactive: str = "No",                         # Text for false value
    initial_value: bool = True                    # Starting value
) -> Union[bool, object]                         # Returns boolean or CANCEL
```
Styled Yes/No confirmation prompt.

example:
```python
from prompts import confirm

result = await confirm(
    message="Do you want to continue?",
    active="Yes",
    inactive="No"
)
```

### spinner()
### spinner()
```python
# As context manager
async with spinner(
    message: str = '',                            # Spinner message
    options: Optional[Dict] = None                # Styling options
) as spin:
    spin.update("New message")                    # Update message

# As decorator
@with_spinner(message: str = '')
async def my_function():
    pass
```
Styled loading spinner with async context manager support.

example:
```python
from prompts import spinner
import asyncio

async def main():
    async with spinner("Installing dependencies..."):
        await asyncio.sleep(2)
    
    # Or use as decorator
    @with_spinner("Loading...")
    async def long_task():
        await asyncio.sleep(2)
```

### Additional Features

- All prompts support cancellation with Ctrl+C
- Built-in error handling and validation
- Unicode support with fallbacks
- Consistent styling and color themes
- Keyboard navigation (arrow keys, vim-style hjkl)

```

### __init__.py
- Size: 74.0 B
- Last Modified: 2024-12-09 13:23:29
- Created: 2024-12-09 07:31:12

#### Content:
```py
from . import core
from . import prompts

__all__ = ['core', 'prompts']
```

### core\__init__.py
- Size: 420.0 B
- Last Modified: 2024-12-09 13:09:29
- Created: 2024-12-09 01:11:30

#### Content:
```py
from .password import PasswordPrompt
from .text import TextPrompt
from .confirm import ConfirmPrompt
from .select import SelectPrompt
from .multiselect import MultiSelectPrompt, Option
from .select_key import SelectKeyPrompt
from .prompt import is_cancel
from .spinner import Spinner

from typing import Any
from dataclasses import dataclass
@dataclass
class Option:
    value: Any
    label: str = ''
    hint: str = ''
```

### core\confirm.py
- Size: 1.8 KB
- Last Modified: 2024-12-09 07:30:41
- Created: 2024-12-09 00:56:08

#### Content:
```py
from core.prompt import *
from typing import Optional, Callable, Any, Union

class ConfirmPrompt(Prompt):
    def __init__(
        self,
        render: Callable[['ConfirmPrompt'], Optional[str]],
        active: str = 'Yes',
        inactive: str = 'No',
        initial_value: bool = False,
        debug: bool = False
    ):
        super().__init__(
            render=render,
            initial_value=initial_value,
            debug=debug,
            track_value=False  # Important: we're handling value tracking differently for confirm
        )
        
        self.active = active
        self.inactive = inactive
        self.value = initial_value
        
        # Set up event handlers
        self.on('value', self._handle_value)
        self.on('confirm', self._handle_confirm)
        self.on('cursor', self._handle_cursor)
    
    @property
    def cursor(self) -> int:
        return 0 if self.value else 1
    
    @property
    def _value(self) -> bool:
        return self.cursor == 0
    
    def _handle_value(self, *args):
        """Handle value changes."""
        self.value = self._value
    
    def _handle_confirm(self, confirm: bool):
        """Handle confirmation (y/n key press)."""
        sys.stdout.write('\033[A')  # Move cursor up one line
        self.value = confirm
        self.state = 'submit'
        self.close()
    
    def _handle_cursor(self, direction: str):
        """Handle cursor movement (left/right/up/down)."""
        if direction in ('left', 'right', 'up', 'down'):
            self.value = not self.value
    
    def handle_key(self, key: str) -> bool:
        """Override key handling for confirm-specific behavior."""
        if key.lower() in ('y', 'n'):
            self._handle_confirm(key.lower() == 'y')
            return False
        
        return super().handle_key(key)

```

### core\multiselect.py
- Size: 3.3 KB
- Last Modified: 2024-12-09 07:30:45
- Created: 2024-12-09 01:10:38

#### Content:
```py
from core.prompt import *
from core.select import Option
from typing import Any, Generic, TypeVar, List, Optional

T = TypeVar('T')

class MultiSelectPrompt(Prompt, Generic[T]):
    def __init__(
        self,
        render: Callable[['MultiSelectPrompt'], Optional[str]],
        options: List[Option],
        initial_values: List[Any] = None,
        required: bool = False,
        cursor_at: Any = None,
        debug: bool = False
    ):
        super().__init__(
            render=render,
            debug=debug,
            track_value=False  # We handle value tracking ourselves
        )
        
        self.options = options
        self.value = list(initial_values or [])
        self._cursor = max(
            next((i for i, opt in enumerate(options) if opt.value == cursor_at), 0),
            0
        )
        self.required = required
        
        # Set up event handlers
        self.on('key', self._handle_key)
        self.on('cursor', self._handle_cursor)
    
    @property
    def cursor(self) -> int:
        return self._cursor
    
    @cursor.setter
    def cursor(self, value: int):
        self._cursor = value
    
    @property
    def _value(self) -> Any:
        """Get the value at current cursor position."""
        return self.options[self.cursor].value
    
    def toggle_all(self):
        """Toggle all options selection."""
        all_selected = len(self.value) == len(self.options)
        if all_selected:
            self.value = [] if not self.required else [self._value]
        else:
            self.value = [opt.value for opt in self.options]
    
    def toggle_value(self):
        """Toggle current value selection."""
        current = self._value
        if current in self.value:
            # Don't deselect if it's the last item and required is True
            if not (self.required and len(self.value) == 1):
                self.value = [v for v in self.value if v != current]
        else:
            self.value = [*self.value, current]
    
    def _handle_key(self, char: str):
        """Handle key press events."""
        if char == 'a':
            self.toggle_all()
    
    def _handle_cursor(self, key: str):
        """Handle cursor movement and space selection."""
        if key in ('left', 'up'):
            self.cursor = (
                len(self.options) - 1 if self.cursor == 0 
                else self.cursor - 1
            )
        elif key in ('down', 'right'):
            self.cursor = (
                0 if self.cursor == len(self.options) - 1 
                else self.cursor + 1
            )
        elif key == 'space':
            self.toggle_value()
    
    def handle_key(self, key: str) -> bool:
        """Override key handling for multi-select specific behavior."""
        if key == readchar.key.ENTER:
            if self.required and not self.value:
                self.error = "At least one option must be selected"
                self.state = 'error'
                return True
            
            if self.validate:
                problem = self.validate(self.value)
                if problem:
                    self.error = problem
                    self.state = 'error'
                    return True
            
            self.state = 'submit'
            return False
            
        return super().handle_key(key)

```

### core\password.py
- Size: 2.3 KB
- Last Modified: 2024-12-09 07:30:43
- Created: 2024-12-09 00:52:26

#### Content:
```py
from core.prompt import *
from typing import Optional, Callable, Any, Union

class PasswordPrompt(Prompt):
    def __init__(
        self,
        render: Callable[['PasswordPrompt'], Optional[str]],
        mask: str = '•',
        placeholder: str = '',
        validate: Optional[Callable[[Any], Optional[str]]] = None,
        debug: bool = False
    ):
        super().__init__(
            render=render,
            placeholder=placeholder,
            initial_value='',
            validate=validate,
            debug=debug
        )
        
        self._mask = mask
        self.value_with_cursor = ''
        self._text_buffer = []
        
        self.on('finalize', self._handle_finalize)
        self.on('key', self._handle_key)
        
    @property
    def cursor(self) -> int:
        return self._cursor
    
    @property
    def masked(self) -> str:
        """Return the masked version of the value."""
        return self._mask * len(self.value) if self.value else ''
    
    def _handle_finalize(self, *args):
        """Handle the finalize event."""
        self.value_with_cursor = self.masked
    
    def _handle_key(self, char: str):
        """Handle key input events."""
        if char == readchar.key.BACKSPACE:
            if self._cursor > 0:
                self._text_buffer.pop(self._cursor - 1)
                self._cursor -= 1
        elif char.isprintable():
            self._text_buffer.insert(self._cursor, char)
            self._cursor += 1
            
        self.value = ''.join(self._text_buffer)
        self._update_value_with_cursor()
    
    def _update_value_with_cursor(self):
        """Update the value_with_cursor property based on current cursor position."""
        color = Color()
        if self._cursor >= len(self.value):
            self.value_with_cursor = f"{self.masked}{color.inverse(color.hidden('_'))}"
        else:
            s1 = self.masked[:self._cursor]
            s2 = self.masked[self._cursor:]
            self.value_with_cursor = f"{s1}{color.inverse(s2[0])}{s2[1:]}"
    
    async def prompt(self) -> Union[str, object]:
        """Override prompt method to initialize text buffer."""
        self._text_buffer = list(self.initial_value) if self.initial_value else []
        self._cursor = len(self._text_buffer)
        self._update_value_with_cursor()
        return await super().prompt()
```

### core\prompt.py
- Size: 7.4 KB
- Last Modified: 2024-12-09 13:23:56
- Created: 2024-12-09 00:57:38

#### Content:
```py
import sys
import shutil
import readchar
from typing import Any, Callable, Dict, List, Optional, Union

# Constants
CANCEL = object()  # Symbol equivalent
KEYS = {'up', 'down', 'left', 'right', 'space', 'enter'}
ALIASES = {
    'k': 'up',
    'j': 'down',
    'h': 'left',
    'l': 'right'
}

def is_cancel(value: Any) -> bool:
    return value is CANCEL

class Color:
    """Simple color handling class to mimic picocolors functionality."""
    @staticmethod
    def inverse(text: str) -> str:
        return f"\033[7m{text}\033[27m"
    
    @staticmethod
    def hidden(text: str) -> str:
        return f"\033[8m{text}\033[28m"

def wrap_ansi(text: str, width: int, hard: bool = False) -> str:
    """Simple text wrapping implementation."""
    lines = []
    for line in text.split('\n'):
        while len(line) > width:
            if hard:
                lines.append(line[:width])
                line = line[width:]
            else:
                space_index = line[:width].rfind(' ')
                if space_index == -1:
                    space_index = width
                lines.append(line[:space_index])
                line = line[space_index:].lstrip()
        lines.append(line)
    return '\n'.join(lines)

class Prompt:
    def __init__(
        self,
        render: Callable[['Prompt'], Optional[str]],
        placeholder: str = '',
        initial_value: Any = None,
        validate: Optional[Callable[[Any], Optional[str]]] = None,
        debug: bool = False,
        track_value: bool = True
    ):
        self._subscribers: Dict[str, List[dict]] = {}
        self.render_fn = render
        self.placeholder = placeholder
        self.initial_value = initial_value
        self.validate = validate
        self.debug = debug
        self._track = track_value
        
        # State
        self.state = 'initial'  # One of: initial, active, cancel, submit, error
        self.value = initial_value
        self.error = ''
        self._cursor = 0
        self._prev_frame = ''
        self._frame_lines = 0
        self._start_line = 0  # Track where our prompt starts
        
        # Terminal settings
        self.cols = shutil.get_terminal_size().columns

    def _save_cursor_position(self):
        """Save current cursor position."""
        sys.stdout.write('\033[s')

    def _restore_cursor_position(self):
        """Restore saved cursor position."""
        sys.stdout.write('\033[u')

    def _move_to_start(self):
        """Move cursor to start of prompt area."""
        if self._frame_lines > 0:
            sys.stdout.write(f"\033[{self._frame_lines}A")

    def _clear_lines(self, count: int):
        """Clear specified number of lines."""
        for _ in range(count):
            sys.stdout.write('\033[2K')  # Clear line
            sys.stdout.write('\033[1B')  # Move down
        sys.stdout.write(f"\033[{count}A")  # Move back up
    
    def on(self, event: str, callback: Callable[..., Any]) -> None:
        """Add an event listener."""
        if event not in self._subscribers:
            self._subscribers[event] = []
        self._subscribers[event].append({'cb': callback, 'once': False})
    
    def once(self, event: str, callback: Callable[..., Any]) -> None:
        """Add a one-time event listener."""
        if event not in self._subscribers:
            self._subscribers[event] = []
        self._subscribers[event].append({'cb': callback, 'once': True})
    
    def emit(self, event: str, *args: Any) -> None:
        """Emit an event to all listeners."""
        if event not in self._subscribers:
            return
            
        cleanup = []
        for sub in self._subscribers[event]:
            sub['cb'](*args)
            if sub['once']:
                cleanup.append(sub)
                
        for sub in cleanup:
            self._subscribers[event].remove(sub)
    
    def handle_key(self, key: str) -> bool:
        """Handle a keypress. Returns True if should continue, False if should exit."""
        if self.state == 'error':
            self.state = 'active'

        # Special key handling
        if key == readchar.key.CTRL_C:
            self.state = 'cancel'
            return False
            
        elif key == readchar.key.ENTER:
            if self.validate:
                problem = self.validate(self.value)
                if problem:
                    self.error = problem
                    self.state = 'error'
                    return True
            self.state = 'submit'
            return False
            
        # Handle navigation keys
        elif key in (readchar.key.UP, 'k'):
            self.emit('cursor', 'up')
        elif key in (readchar.key.DOWN, 'j'):
            self.emit('cursor', 'down')
        elif key in (readchar.key.LEFT, 'h'):
            self.emit('cursor', 'left')
        elif key in (readchar.key.RIGHT, 'l'):
            self.emit('cursor', 'right')
            
        # Handle regular input
        elif key == ' ':
            self.emit('cursor', 'space')
        elif key in 'yYnN':
            self.emit('confirm', key.lower() == 'y')
        elif key == '\t' and self.placeholder and not self.value:
            self.value = self.placeholder
            self._cursor = len(self.value)
            self.emit('value', self.value)
        
        if key and len(key) == 1:
            self.emit('key', key.lower())
            
        return True

    def render(self) -> None:
        """Render the current frame."""
        frame = wrap_ansi(self.render_fn(self) or '', self.cols, hard=True)
        if frame == self._prev_frame:
            return

        new_lines = frame.count('\n') + 1

        if self.state == 'initial':
            # First render - just write and track position
            sys.stdout.write('\033[?25l')  # Hide cursor
            self._save_cursor_position()  # Save starting position
            sys.stdout.write(frame)
        else:
            # Move to start of prompt area
            self._restore_cursor_position()
            # Clear prompt area
            self._clear_lines(self._frame_lines)
            # Write new frame
            sys.stdout.write(frame)
        
        sys.stdout.flush()
        self._prev_frame = frame
        self._frame_lines = new_lines
        
        if self.state == 'initial':
            self.state = 'active'

    async def prompt(self) -> Union[str, object]:
        """Start the prompt and return the final value."""
        try:
            if self.initial_value is not None and self._track:
                self.value = str(self.initial_value)
                self._cursor = len(self.value)
            
            self.render()
            
            while True:
                key = readchar.readkey()
                if not self.handle_key(key):
                    break
                self.render()
            
            # Handle final state
            self._restore_cursor_position()
            self._clear_lines(self._frame_lines)
            if self.state in ('submit', 'cancel'):
                final_frame = self.render_fn(self)
                sys.stdout.write(final_frame)
                sys.stdout.flush()
            
            return self.value if self.state == 'submit' else CANCEL
            
        finally:
            sys.stdout.write('\033[?25h')  # Show cursor
            self.emit(self.state, self.value)
            self._subscribers.clear()

    def close(self) -> None:
        """Clean up and restore terminal settings."""
        sys.stdout.write('\033[?25h')  # Show cursor
```

### core\select.py
- Size: 2.1 KB
- Last Modified: 2024-12-09 07:46:00
- Created: 2024-12-09 01:13:18

#### Content:
```py
from core.prompt import *
from dataclasses import dataclass
from typing import Any, Generic, TypeVar, List, Optional, Callable, TypeVar

T = TypeVar('T')

@dataclass
class Option:
    value: Any
    label: str = ''  # Optional label, will use str(value) if not provided

class SelectPrompt(Prompt):
    def __init__(
        self,
        render: Callable[['SelectPrompt'], str],
        options: List['Option'],
        initial_value: Any = None,
        validate: Optional[Callable[[Any], Optional[str]]] = None,
        debug: bool = False
    ):
        super().__init__(
            render=render,
            validate=validate,
            debug=debug,
            track_value=False
        )
        
        self.options = options
        self._cursor = 0
        
        # Set initial cursor position if initial_value provided
        if initial_value is not None:
            for i, opt in enumerate(options):
                if opt.value == initial_value:
                    self._cursor = i
                    break
        
        self.value = self.options[self._cursor].value
    
    @property
    def cursor(self) -> int:
        return self._cursor
    
    def handle_key(self, key: str) -> bool:
        """Handle keyboard input."""
        if key == readchar.key.CTRL_C:
            self.state = 'cancel'
            return False
            
        elif key == readchar.key.ENTER:
            if self.validate:
                problem = self.validate(self.value)
                if problem:
                    self.error = problem
                    self.state = 'error'
                    return True
            self.state = 'submit'
            return False
            
        # Handle arrow keys
        elif key in (readchar.key.UP, 'k'):
            self._cursor = (self._cursor - 1) % len(self.options)
            self.value = self.options[self._cursor].value
            
        elif key in (readchar.key.DOWN, 'j'):
            self._cursor = (self._cursor + 1) % len(self.options)
            self.value = self.options[self._cursor].value
            
        return True
```

### core\select_key.py
- Size: 2.1 KB
- Last Modified: 2024-12-09 07:30:47
- Created: 2024-12-09 01:10:42

#### Content:
```py
from core.prompt import *
from core.select import Option
from typing import Any, Generic, TypeVar, List, Optional, TypeVar, Callable

T = TypeVar('T')

class SelectKeyPrompt(Prompt, Generic[T]):
    def __init__(
        self,
        render: Callable[['SelectKeyPrompt'], Optional[str]],
        options: List[Option],
        initial_value: Any = None,
        debug: bool = False
    ):
        super().__init__(
            render=render,
            debug=debug,
            track_value=False  # We handle value tracking ourselves
        )
        
        self.options = options
        self._cursor = 0
        
        # Extract the first character of each option value as the key
        self.keys = {
            str(opt.value)[0].lower(): opt.value 
            for opt in options 
            if str(opt.value)
        }
        
        # Set initial cursor position based on initial value
        if initial_value is not None:
            initial_key = str(initial_value)[0].lower()
            self._cursor = max(
                next((i for i, opt in enumerate(options) 
                      if str(opt.value)[0].lower() == initial_key), 0),
                0
            )
        
        # Set up event handler
        self.on('key', self._handle_key)
    
    @property
    def cursor(self) -> int:
        return self._cursor
    
    @cursor.setter
    def cursor(self, value: int):
        self._cursor = value
    
    def _handle_key(self, key: str):
        """Handle key press events."""
        if key not in self.keys:
            return
            
        self.value = self.keys[key]
        self.state = 'submit'
        self.emit('submit')
    
    def handle_key(self, key: str) -> bool:
        """Override key handling for key-select specific behavior."""
        if key == readchar.key.ENTER:
            if self.validate:
                problem = self.validate(self.value)
                if problem:
                    self.error = problem
                    self.state = 'error'
                    return True
                    
            self.state = 'submit'
            return False
            
        return super().handle_key(key)
```

### core\spinner.py
- Size: 1.9 KB
- Last Modified: 2024-12-09 12:29:24
- Created: 2024-12-09 07:29:58

#### Content:
```py
import sys
import threading
import time
from utils.styling import Color, S_BAR, S_STEP_SUBMIT, S_STEP_CANCEL, S_STEP_ERROR, UNICODE

class Spinner:
    """Terminal spinner for loading states."""
    def __init__(self):
        self.frames = ['◒', '◐', '◓', '◑'] if UNICODE else ['•', 'o', 'O', '0']
        self.delay = 0.08 if UNICODE else 0.12
        self.active = False
        self.message = ''
        self._timer = None
        self._frame_index = 0

    def start(self, message: str = ''):
        """Start the spinner with an optional message."""
        self.message = message.rstrip('.')
        self.active = True
        
        def spin():
            while self.active:
                frame = Color.magenta(self.frames[self._frame_index])
                dots = '.' * (1 + (int(time.time() * 8) % 3))
                sys.stdout.write('\r\033[K' + f"{frame}  {self.message}{dots}")
                sys.stdout.flush()
                self._frame_index = (self._frame_index + 1) % len(self.frames)
                time.sleep(self.delay)

        self._timer = threading.Thread(target=spin)
        self._timer.daemon = True
        sys.stdout.write(f"{Color.gray(S_BAR)}\n")
        self._timer.start()

    def stop(self, message: str = None, code: int = 0):
        """Stop the spinner and show final message."""
        self.active = False
        if self._timer:
            self._timer.join()
        
        final_message = message or self.message
        step = (Color.green(S_STEP_SUBMIT) if code == 0 else 
                Color.red(S_STEP_CANCEL) if code == 1 else 
                Color.red(S_STEP_ERROR))
        
        sys.stdout.write('\r\033[K' + f"{step}  {final_message}\n")
        sys.stdout.flush()

    def update(self, message: str):
        """Update the spinner message."""
        self.message = message.rstrip('.')
```

### core\text.py
- Size: 2.4 KB
- Last Modified: 2024-12-09 07:53:57
- Created: 2024-12-09 00:52:28

#### Content:
```py
from core.prompt import *
from utils.styling import Color
from typing import Optional, Callable, Any, Union

class TextPrompt(Prompt):
    def __init__(
        self,
        render: Callable[['TextPrompt'], str],
        placeholder: str = '',
        default_value: str = '',
        initial_value: str = '',
        validate: Optional[Callable[[str], Optional[str]]] = None,
        debug: bool = False
    ):
        super().__init__(
            render=render,
            placeholder=placeholder,
            initial_value=initial_value,
            validate=validate,
            debug=debug
        )
        
        self.default_value = default_value
        self.value_with_cursor = ''
        self._text_buffer = list(initial_value) if initial_value else []
        
        # Set up event handlers
        self.on('finalize', self._handle_finalize)
        self.on('key', self._handle_key)
        self._cursor = len(self._text_buffer)
        
    @property
    def cursor(self) -> int:
        return self._cursor
    
    def _handle_finalize(self, *args):
        """Handle the finalize event."""
        if not self.value and self.default_value:
            self.value = self.default_value
        self.value_with_cursor = self.value
    
    def _handle_key(self, char: str):
        """Handle key input events."""
        if char == readchar.key.BACKSPACE:
            if self._cursor > 0:
                self._text_buffer.pop(self._cursor - 1)
                self._cursor -= 1
        elif char.isprintable():
            self._text_buffer.insert(self._cursor, char)
            self._cursor += 1
            
        self.value = ''.join(self._text_buffer)
        self._update_value_with_cursor()
    
    def _update_value_with_cursor(self):
        """Update the value_with_cursor property based on current cursor position."""
        if self._cursor >= len(self.value):
            self.value_with_cursor = f"{self.value}{Color.inverse(Color.hidden('_'))}"
        else:
            s1 = self.value[:self._cursor]
            s2 = self.value[self._cursor:]
            self.value_with_cursor = f"{s1}{Color.inverse(s2[0])}{s2[1:]}"
    
    async def prompt(self) -> str:
        """Start the prompt and handle initial setup."""
        self._text_buffer = list(self.initial_value) if self.initial_value else []
        self._cursor = len(self._text_buffer)
        self._update_value_with_cursor()
        return await super().prompt()
```

### dist\pyclack_cli-0.1.0-py3-none-any.whl
- Size: 18.4 KB
- Last Modified: 2024-12-09 13:48:50
- Created: 2024-12-09 13:48:50

#### Content:
```whl
[Binary file]
```

### dist\pyclack_cli-0.1.0.tar.gz
- Size: 12.5 KB
- Last Modified: 2024-12-09 13:48:48
- Created: 2024-12-09 13:48:48

#### Content:
```gz
[Binary file]
```

### docs.py
- Size: 5.2 KB
- Last Modified: 2024-12-09 13:57:14
- Created: 2024-12-09 13:54:18

#### Content:
```py
import os
from datetime import datetime
import argparse
from pathlib import Path

# Files and patterns to ignore
IGNORED_EXTENSIONS = {'pyc', 'pyo', 'pyd', 'class', 'o', 'so', 'dll', 'exe'}
IGNORED_PATTERNS = {
    '__pycache__',
    '.git',
    '.pytest_cache',
    'node_modules',
    'venv',
    '.env'
}

def should_ignore_file(path):
    """Check if the file or directory should be ignored"""
    # Check if any parent directory should be ignored
    parts = Path(path).parts
    if any(part in IGNORED_PATTERNS for part in parts):
        return True
        
    # Check file extension
    if path.suffix.lstrip('.') in IGNORED_EXTENSIONS:
        return True
            
    return False

def get_file_content(filepath):
    """Get the content of a file, handling binary files appropriately"""
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            return f.read()
    except (UnicodeDecodeError, IsADirectoryError):
        return "[Binary file]"
    except FileNotFoundError:
        return "[File not found]"
    except Exception as e:
        return f"[Error reading file: {str(e)}]"

def get_file_info(filepath):
    """Get file information including size and last modified time"""
    try:
        stats = os.stat(filepath)
        return {
            'size': stats.st_size,
            'modified': datetime.fromtimestamp(stats.st_mtime).strftime('%Y-%m-%d %H:%M:%S'),
            'created': datetime.fromtimestamp(stats.st_ctime).strftime('%Y-%m-%d %H:%M:%S')
        }
    except Exception as e:
        return {
            'size': 0,
            'modified': 'Unknown',
            'created': 'Unknown',
            'error': str(e)
        }

def scan_directory(directory):
    """Scan directory and return information about all files"""
    files_info = []
    
    for root, dirs, files in os.walk(directory):
        # Remove ignored directories
        dirs[:] = [d for d in dirs if d not in IGNORED_PATTERNS]
        
        for file in files:
            filepath = Path(root) / file
            if not should_ignore_file(filepath):
                files_info.append({
                    'path': str(filepath.relative_to(directory)),
                    'info': get_file_info(filepath),
                    'content': get_file_content(filepath)
                })
    
    return files_info

def format_size(size_in_bytes):
    """Format file size in human-readable format"""
    for unit in ['B', 'KB', 'MB', 'GB']:
        if size_in_bytes < 1024:
            return f"{size_in_bytes:.1f} {unit}"
        size_in_bytes /= 1024
    return f"{size_in_bytes:.1f} TB"

def generate_markdown_summary(directory, output_file='directory_docs.md'):
    """Generate a markdown file with directory contents summary"""
    files = scan_directory(directory)
    
    if not files:
        return "No files found."
    
    # Start with a header including timestamp
    markdown = [
        f"# Directory Documentation",
        f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        f"Base directory: {os.path.abspath(directory)}",
        "",
        "## Files Overview",
        "",
        "| File | Size | Last Modified | Created |",
        "|------|------|---------------|----------|"
    ]
    
    # Add files overview table
    for file_info in sorted(files, key=lambda x: x['path']):
        info = file_info['info']
        markdown.append(
            f"| {file_info['path']} | {format_size(info['size'])} | {info['modified']} | {info['created']} |"
        )
    
    # Add detailed file contents
    markdown.extend([
        "",
        "## Detailed Contents",
        ""
    ])
    
    for file_info in sorted(files, key=lambda x: x['path']):
        path = file_info['path']
        content = file_info['content']
        ext = os.path.splitext(path)[1].lstrip('.') or 'txt'
        
        markdown.extend([
            f"### {path}",
            f"- Size: {format_size(file_info['info']['size'])}",
            f"- Last Modified: {file_info['info']['modified']}",
            f"- Created: {file_info['info']['created']}",
            "",
            "#### Content:",
            f"```{ext}",
            content,
            "```",
            ""
        ])
    
    content = '\n'.join(markdown)
    
    # Write to file if output_file is provided
    if output_file:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(content)
        print(f"Documentation has been written to {output_file}")
    
    return content

def parse_arguments():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(description='Directory documentation generator')
    parser.add_argument(
        '-d', '--directory',
        default='.',
        help='Directory to document (default: current directory)'
    )
    parser.add_argument(
        '-o', '--output',
        default='directory_docs.md',
        help='Output file path (default: directory_docs.md)'
    )
    return parser.parse_args()

def main():
    args = parse_arguments()
    generate_markdown_summary(args.directory, args.output)

if __name__ == "__main__":
    main()
```

### main.py
- Size: 2.5 KB
- Last Modified: 2024-12-09 13:23:24
- Created: 2024-12-09 01:14:42

#### Content:
```py
from prompts import text, password, select, multiselect, confirm, create_note, note, intro, outro, Option, is_cancel
from prompts import *
import asyncio

async def simulate_install():
    """Simulate installation process with updates."""
    await asyncio.sleep(1)
    return "Installation complete!"

@with_spinner("Installing dependencies...")
async def install_deps():
    """Example of using spinner as a decorator."""
    await asyncio.sleep(2)
    return "Dependencies installed!"

async def main():
    # Intro
    intro("pyclack")
    
    # Project location
    project_path = await text(
        message="Where should we create your project?",
        placeholder=".",
        initial_value="."
    )
    if is_cancel(project_path):
        return
    
    pwd = await password(
        message = "Enter your secret",
        validate=lambda x: "password is too short" if len(x) < 5 else None
    )
    if is_cancel(pwd):
        return
    
    # Project type
    project_type = await select(
        message=f'Pick a project type within "{project_path}"',
        options=[
            Option("typescript", "TypeScript"),
            Option("javascript", "JavaScript")
        ],
        initial_value="typescript"
    )
    if is_cancel(project_type):
        return
    
    # Tools selection
    tools = await multiselect(
        message="Select additional tools.",
        options=[
            Option("prettier", "Prettier"),
            Option("eslint", "ESLint"),
            Option("jest", "Jest")
        ],
        initial_values=["prettier", "eslint"]
    )
    if is_cancel(tools):
        return
    
    # Install dependencies
    install = await confirm(
        message="Install dependencies?",
        active="Yes",
        inactive="No",
        initial_value=True
    )
    if is_cancel(install):
        return

    if install:
        # Method 1: Using context manager
        async with spinner("Setting up project...") as spin:
            await asyncio.sleep(1)
            spin.update("Installing packages...")
            await asyncio.sleep(1)
            spin.update("Configuring tools...")
            await asyncio.sleep(1)
            spin.update("Dependencies installed!")

        # Method 2: Using decorated function
        # await install_deps()
    
    # Next steps
    steps = [
        "cd .",
        "pnpm dev"
    ]
    
    note(title="Next steps.", next_steps=steps)
    outro(f"{Color.dim(f'Problems? {link(url='https://github.com/Bbalduzz/pyclack')}')}")

if __name__ == "__main__":
    asyncio.run(main())
```

### prompts\__init__.py
- Size: 2.9 KB
- Last Modified: 2024-12-09 13:09:55
- Created: 2024-12-09 13:03:27

#### Content:
```py
from .text import text
from .password import password
from .select import select
from .mutliselect import multiselect
from .confirm import confirm
from .spinner import spinner, with_spinner
from core import Option, is_cancel
from utils.styling import Color, strip_ansi, S_BAR, S_STEP_SUBMIT, S_CORNER_TOP_RIGHT, S_BAR_H, S_CONNECT_LEFT, S_CORNER_BOTTOM_RIGHT, S_BAR_START, S_BAR_END

def create_note(message: str = '', title: str = '') -> str:
    lines = f"\n{message}\n".split('\n')
    title_len = len(strip_ansi(title))
    max_len = max(
        max(len(strip_ansi(ln)) for ln in lines),
        title_len
    ) + 2

    formatted_lines = [
        f"{Color.gray(S_BAR)}  {Color.dim(ln)}{' ' * (max_len - len(strip_ansi(ln)))}{Color.gray(S_BAR)}"
        for ln in lines
    ]
    
    note_display = "\n".join(formatted_lines)
    
    return (
        f"{Color.gray(S_BAR)}\n"
        f"{Color.reset(S_STEP_SUBMIT)}  {Color.reset(title)} {Color.gray(S_BAR_H * max(max_len - title_len - 1, 1))}{Color.gray(S_CORNER_TOP_RIGHT)}\n"
        f"{note_display}\n"
        f"{Color.gray(S_CONNECT_LEFT)}{Color.gray(S_BAR_H * (max_len + 2))}{Color.gray(S_CORNER_BOTTOM_RIGHT)}\n"
    )

def note(message: str = None, title: str = '', next_steps: list = []) -> str:
    print(create_note(
        message=message if message else '\n'.join(next_steps),
        title=title if title else "Next steps."
    ))

def intro(title: str = '', options=None) -> None:
    """Display intro with optional title and styling.
    
    Args:
        title: Optional title text
        options: Dict with 'color' styling (defaults to gray)
    """
    if options is None:
        options = {"color": Color.gray}
    
    color = options.get('color', Color.gray)
    print("\033[H\033[J")  # Clear screen
    print(f"{color(S_BAR_START)}  {title}")

def outro(message: str = '', options=None) -> None:
    """Display outro with optional message and styling.
    
    Args:
        message: Optional message text
        options: Dict with 'color' styling (defaults to gray) 
    """
    if options is None:
        options = {"color": Color.gray}
    
    color = options.get('color', Color.gray)
    print(f"{color(S_BAR)}\n{color(S_BAR_END)}  {message}\n")

def link(url, label=None, options=None):
    """Generate a terminal hyperlink with optional styling.
    
    Args:
        url: The URL to link to
        label: Optional text to display (defaults to URL if None)
        options: Dict with 'color' and 'bg_color' keys for styling
    """
    if options is None:
        options = {"color": Color.cyan, "bg_color": None}
    
    label = label or url
    color = options.get('color')
    
    # Build link with color function applied to the whole link if color exists
    link = f"\033]8;;{url}\033\\{label}\033]8;;\033\\"
    return color(link) if color else link
```

### prompts\confirm.py
- Size: 1.7 KB
- Last Modified: 2024-12-09 13:08:29
- Created: 2024-12-09 12:56:16

#### Content:
```py
from typing import Union, Any
from core import ConfirmPrompt, is_cancel
from utils.styling import (
    Color, symbol, S_BAR, S_BAR_END, S_RADIO_ACTIVE, S_RADIO_INACTIVE
)

async def confirm(
    message: str,
    active: str = "Yes",
    inactive: str = "No",
    initial_value: bool = True
) -> Union[bool, object]:
    def render(prompt: ConfirmPrompt) -> str:
        title = f"{Color.gray(S_BAR)}\n{symbol(prompt.state)}  {message}\n"
        value = active if prompt.value else inactive

        if prompt.state == 'submit':
            return f"{title}"
        elif prompt.state == 'cancel':
            return (f"{title}{Color.gray(S_BAR)}  "
                   f"{Color.strikethrough(Color.dim(value))}\n"
                   f"{Color.gray(S_BAR)}")
        else:
            active_style = (
                f"{Color.green(S_RADIO_ACTIVE)} {active}"
                if prompt.value else
                f"{Color.dim(S_RADIO_INACTIVE)} {Color.dim(active)}"
            )
            inactive_style = (
                f"{Color.green(S_RADIO_ACTIVE)} {inactive}"
                if not prompt.value else
                f"{Color.dim(S_RADIO_INACTIVE)} {Color.dim(inactive)}"
            )
            return (f"{title}{Color.cyan(S_BAR)}  "
                   f"{active_style} {Color.dim('/')} {inactive_style}\n"
                   f"{Color.cyan(S_BAR_END)}\n")

    prompt = ConfirmPrompt(
        render=render,
        active=active,
        inactive=inactive,
        initial_value=initial_value
    )
    result = await prompt.prompt()
    
    if is_cancel(result):
        return result
    
    print(f"{Color.gray(S_BAR)}  {Color.dim(result)}")
    return result

```

### prompts\mutliselect.py
- Size: 4.2 KB
- Last Modified: 2024-12-09 13:09:38
- Created: 2024-12-09 12:59:11

#### Content:
```py
from typing import List, Any, Optional, Union, Any
from core import MultiSelectPrompt, Option, is_cancel
from utils.styling import Color, symbol, limit_options, S_BAR, S_BAR_END, S_CHECKBOX_ACTIVE, S_CHECKBOX_SELECTED, S_CHECKBOX_INACTIVE

async def multiselect(
    message: str,
    options: List[Option],
    initial_values: List[Any] = None,
    max_items: Optional[int] = None,
    required: bool = True,
    cursor_at: Any = None
) -> Union[List[Any], object]:
    
    def render(prompt: MultiSelectPrompt) -> str:
        def opt(option: Option, state: str) -> str:
            label = option.label or str(option.value)
            if state == 'active':
                return (f"{Color.cyan(S_CHECKBOX_ACTIVE)} {label} "
                       f"{option.hint and Color.dim(f'({option.hint})') or ''}")
            elif state == 'selected':
                return f"{Color.green(S_CHECKBOX_SELECTED)} {Color.dim(label)}"
            elif state == 'cancelled':
                return Color.strikethrough(Color.dim(label))
            elif state == 'active-selected':
                return (f"{Color.green(S_CHECKBOX_SELECTED)} {label} "
                       f"{option.hint and Color.dim(f'({option.hint})') or ''}")
            elif state == 'submitted':
                return Color.dim(label)
            return f"{Color.dim(S_CHECKBOX_INACTIVE)} {Color.dim(label)}"

        title = f"{Color.gray(S_BAR)}\n{symbol(prompt.state)}  {message}\n"

        if prompt.state == 'submit':
            selected = [opt for opt in prompt.options if opt.value in prompt.value]
            selected_labels = [opt.label for opt in selected]
            return (f"{Color.gray(S_BAR)}\n"
                   f"{symbol(prompt.state)}  {message}\n")

        if prompt.state == 'cancel':
            selected = [opt for opt in prompt.options if opt.value in prompt.value]
            selected_str = Color.dim(', ').join(opt(o, 'cancelled') for o in selected)
            return (f"{title}{Color.gray(S_BAR)}  "
                   f"{selected_str}\n{Color.gray(S_BAR) if selected_str else ''}")
        elif prompt.state == 'error':
            footer = prompt.error.split('\n')
            footer = [
                f"{Color.yellow(S_BAR_END)}  {Color.yellow(footer[0])}",
                *[f"   {line}" for line in footer[1:]]
            ]
            styled_options = limit_options(
                options=prompt.options,
                cursor=prompt.cursor,
                max_items=max_items,
                style=lambda item, active: opt(
                    item,
                    'active-selected' if active and item.value in prompt.value
                    else 'selected' if item.value in prompt.value
                    else 'active' if active
                    else 'inactive'
                )
            )
            return (f"{title}{Color.yellow(S_BAR)}  "
                   f"{f'\n{Color.yellow(S_BAR)}  '.join(styled_options)}\n"
                   f"{'\n'.join(footer)}\n")
        else:
            styled_options = limit_options(
                options=prompt.options,
                cursor=prompt.cursor,
                max_items=max_items,
                style=lambda item, active: opt(
                    item,
                    'active-selected' if active and item.value in prompt.value
                    else 'selected' if item.value in prompt.value
                    else 'active' if active
                    else 'inactive'
                )
            )
            return (f"{title}{Color.cyan(S_BAR)}  "
                   f"{f'\n{Color.cyan(S_BAR)}  '.join(styled_options)}\n"
                   f"{Color.cyan(S_BAR_END)}\n")

    prompt = MultiSelectPrompt(
        render=render,
        options=options,
        initial_values=initial_values,
        required=required,
        cursor_at=cursor_at,
        debug=False
    )
    result = await prompt.prompt()
    
    if is_cancel(result):
        return result
    
    # Print final state
    selected = [opt for opt in options if opt.value in result]
    print(f"{Color.gray(S_BAR)}  {Color.dim(', '.join(opt.label for opt in selected))}")
    
    return result
```

### prompts\password.py
- Size: 1.4 KB
- Last Modified: 2024-12-09 12:55:54
- Created: 2024-12-09 12:55:42

#### Content:
```py
from typing import Callable, Optional, Union
from core import PasswordPrompt, is_cancel
from utils.styling import Color, symbol, S_BAR, S_BAR_END, S_PASSWORD_MASK

async def password(
    message: str,
    mask: str = S_PASSWORD_MASK,
    validate: Optional[Callable[[str], Optional[str]]] = None
) -> Union[str, object]:
    def render(prompt: PasswordPrompt) -> str:
        title = f"{Color.gray(S_BAR)}\n{symbol(prompt.state)}  {message}\n"
        value = prompt.value_with_cursor
        masked = prompt.masked

        if prompt.state == 'error':
            return (f"{title.rstrip()}\n"
                   f"{Color.yellow(S_BAR)}  {masked}\n"
                   f"{Color.yellow(S_BAR_END)}  {Color.yellow(prompt.error)}\n")
        elif prompt.state == 'submit':
            return f"{title}"
        elif prompt.state == 'cancel':
            return (f"{title}{Color.gray(S_BAR)}  "
                   f"{Color.strikethrough(Color.dim(masked or ''))}"
                   f"{masked and f'\n{Color.gray(S_BAR)}' or ''}")
        else:
            return f"{title}{Color.cyan(S_BAR)}  {value}\n{Color.cyan(S_BAR_END)}\n"

    prompt = PasswordPrompt(render=render, mask=mask, validate=validate)
    result = await prompt.prompt()
    
    if is_cancel(result):
        return result

    print(f"{Color.gray(S_BAR)}  {Color.dim(S_PASSWORD_MASK * len(result))}")
    return result
```

### prompts\select.py
- Size: 2.1 KB
- Last Modified: 2024-12-09 13:09:48
- Created: 2024-12-09 12:57:22

#### Content:
```py
from typing import List, Any, Optional, Union, Any
from core import SelectPrompt, Option, is_cancel
from utils.styling import Color, symbol, limit_options, S_BAR, S_BAR_END, S_RADIO_ACTIVE, S_RADIO_INACTIVE

async def select(
    message: str,
    options: List[Option],
    initial_value: Any = None,
    max_items: Optional[int] = None
) -> Union[Any, object]:
    def opt(option: Option, state: str) -> str:
        label = option.label or str(option.value)
        if state == 'selected':
            return Color.dim(label)
        elif state == 'active':
            return (f"{Color.green(S_RADIO_ACTIVE)} {label} "
                   f"{option.hint and Color.dim(f'({option.hint})') or ''}")
        elif state == 'cancelled':
            return Color.strikethrough(Color.dim(label))
        else:
            return f"{Color.dim(S_RADIO_INACTIVE)} {Color.dim(label)}"

    def render(prompt: SelectPrompt) -> str:
        title = f"{Color.gray(S_BAR)}\n{symbol(prompt.state)}  {message}\n"

        if prompt.state == 'submit':
            return f"{title}"
        elif prompt.state == 'cancel':
            return (f"{title}{Color.gray(S_BAR)}  "
                   f"{opt(prompt.options[prompt.cursor], 'cancelled')}\n"
                   f"{Color.gray(S_BAR)}")
        else:
            styled_options = limit_options(
                options=prompt.options,
                cursor=prompt.cursor,
                max_items=max_items,
                style=lambda item, active: opt(item, 'active' if active else 'inactive')
            )
            return (f"{title}{Color.cyan(S_BAR)}  "
                   f"{f'\n{Color.cyan(S_BAR)}  '.join(styled_options)}\n"
                   f"{Color.cyan(S_BAR_END)}\n")

    prompt = SelectPrompt(
        render=render,
        options=options,
        initial_value=initial_value
    )
    result = await prompt.prompt()
    
    if is_cancel(result):
        return result
        
    selected_option = next((opt for opt in options if opt.value == result), None)
    if selected_option:
        print(f"{Color.gray(S_BAR)}  {Color.dim(selected_option.label)}")
    return result
```

### prompts\spinner.py
- Size: 1.4 KB
- Last Modified: 2024-12-09 13:03:00
- Created: 2024-12-09 13:02:14

#### Content:
```py
from contextlib import asynccontextmanager
from functools import wraps
from core import Spinner
from utils.styling import Color

@asynccontextmanager
async def spinner(message: str = '', options=None):
    """Async context manager for showing a loading spinner.
    
    Args:
        message: Message to display next to spinner
        options: Dict with 'color' styling (defaults to magenta for spinner)
    
    Usage:
        async with spinner("Loading..."):
            await some_async_operation()
    """
    if options is None:
        options = {"color": Color.magenta}
        
    spin = Spinner()
    try:
        spin.start(message)
        yield spin
    finally:
        spin.stop()

def with_spinner(message: str = ''):
    """Decorator to add a spinner to an async function.
    
    Args:
        message: Message to display next to spinner
    
    Usage:
        @with_spinner("Loading...")
        async def my_function():
            await some_async_operation()
    """
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            async with spinner(message) as spin:
                try:
                    result = await func(*args, **kwargs)
                    return result
                except Exception as e:
                    spin.stop(str(e), code=2)
                    raise
        return wrapper
    return decorator

```

### prompts\text.py
- Size: 1.8 KB
- Last Modified: 2024-12-09 13:05:32
- Created: 2024-12-09 12:54:02

#### Content:
```py
from typing import Callable, Optional, Union, Any
from core import TextPrompt, is_cancel
from utils.styling import Color, symbol, S_BAR, S_BAR_END

async def text(
    message: str,
    placeholder: str = '',
    default_value: str = '',
    initial_value: str = '',
    validate: Optional[Callable[[str], Optional[str]]] = None
) -> Union[str, object]:
    def render(prompt: TextPrompt) -> str:
        title = f"{Color.gray(S_BAR)}\n{symbol(prompt.state)}  {message}\n"
        placeholder_text = (
            Color.inverse(placeholder[0]) + Color.dim(placeholder[1:])
            if placeholder else Color.inverse(Color.hidden('_'))
        )
        value = placeholder_text if not prompt.value else prompt.value_with_cursor

        if prompt.state == 'error':
            return (f"{title.rstrip()}\n"
                   f"{Color.yellow(S_BAR)}  {value}\n"
                   f"{Color.yellow(S_BAR_END)}  {Color.yellow(prompt.error)}\n")
        elif prompt.state == 'submit':
            return (f"{Color.gray(S_BAR)}\n"
                   f"{symbol(prompt.state)}  {message}\n")
        elif prompt.state == 'cancel':
            return (f"{title}{Color.gray(S_BAR)}  "
                   f"{Color.strikethrough(Color.dim(prompt.value or ''))}"
                   f"{prompt.value and prompt.value.strip() and f'\n{Color.gray(S_BAR)}' or ''}")
        else:
            return f"{title}{Color.cyan(S_BAR)}  {value}\n{Color.cyan(S_BAR_END)}\n"

    prompt = TextPrompt(
        render=render,
        placeholder=placeholder,
        initial_value=initial_value,
        default_value=default_value,
        validate=validate
    )
    result = await prompt.prompt()
    
    if is_cancel(result):
        return result
        
    print(f"{Color.gray(S_BAR)}  {Color.dim(result)}")
    return result
```

### pyclack.egg-info\PKG-INFO
- Size: 1.7 KB
- Last Modified: 2024-12-09 13:24:42
- Created: 2024-12-09 13:24:42

#### Content:
```txt
Metadata-Version: 2.1
Name: pyclack
Version: 0.1.0
Summary: A python library for building interactive command line interfaces effortlessly. Inspired by clack.cc
Home-page: https://github.com/Bbalduzz/pyclack
Author: Edoardo Balducci
Author-email: edoardoba2004@gmail.com
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Requires-Python: >=3.7
Description-Content-Type: text/markdown
Requires-Dist: readchar
Provides-Extra: core
Requires-Dist: readchar; extra == "core"
Provides-Extra: prompts
Requires-Dist: readchar; extra == "prompts"
Provides-Extra: all
Requires-Dist: readchar; extra == "all"

<h1 align="center">
  pyclack
  <br>
  <img width="5%" align="center" src="https://img.shields.io/badge/prerelease-8FD28F" alt="logo">
  <img width="4%" align="center" src="https://img.shields.io/badge/python-blue" alt="logo">
</h1>


<p align="center">
  <b>Building interactive command line interfaces effortlessly.</b>
</p>

`/core`: This is your toolkit for building custom CLIs from scratch. It provides robust, unstyled components that give you complete creative freedom while handling all the complex functionality under the hood.

`/prompts`: Need something ready to use? This package offers a collection of beautifully designed prompts with an intuitive API. Just import and start using them - perfect when you want professional results without the custom styling work.

<div align="center">
    <kbd>
      <video width="100%" align="center" src="https://github.com/user-attachments/assets/07b959fb-165e-4419-93ba-74c235a7bc38" alt="demo /prompts">
    </kbd>
</div>


```

### pyclack.egg-info\SOURCES.txt
- Size: 490.0 B
- Last Modified: 2024-12-09 13:24:42
- Created: 2024-12-09 13:24:42

#### Content:
```txt
README.md
setup.py
core/__init__.py
core/confirm.py
core/multiselect.py
core/password.py
core/prompt.py
core/select.py
core/select_key.py
core/spinner.py
core/text.py
prompts/__init__.py
prompts/confirm.py
prompts/mutliselect.py
prompts/password.py
prompts/select.py
prompts/spinner.py
prompts/text.py
pyclack.egg-info/PKG-INFO
pyclack.egg-info/SOURCES.txt
pyclack.egg-info/dependency_links.txt
pyclack.egg-info/requires.txt
pyclack.egg-info/top_level.txt
utils/__init__.py
utils/styling.py
```

### pyclack.egg-info\dependency_links.txt
- Size: 1.0 B
- Last Modified: 2024-12-09 13:24:42
- Created: 2024-12-09 13:24:42

#### Content:
```txt


```

### pyclack.egg-info\requires.txt
- Size: 62.0 B
- Last Modified: 2024-12-09 13:24:42
- Created: 2024-12-09 13:24:42

#### Content:
```txt
readchar

[all]
readchar

[core]
readchar

[prompts]
readchar

```

### pyclack.egg-info\top_level.txt
- Size: 19.0 B
- Last Modified: 2024-12-09 13:24:42
- Created: 2024-12-09 13:24:42

#### Content:
```txt
core
prompts
utils

```

### pyclack_cli.egg-info\PKG-INFO
- Size: 1.7 KB
- Last Modified: 2024-12-09 13:48:48
- Created: 2024-12-09 13:48:48

#### Content:
```txt
Metadata-Version: 2.1
Name: pyclack-cli
Version: 0.1.0
Summary: A python library for building interactive command line interfaces effortlessly. Inspired by clack.cc
Home-page: https://github.com/Bbalduzz/pyclack
Author: Edoardo Balducci
Author-email: edoardoba2004@gmail.com
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Requires-Python: >=3.7
Description-Content-Type: text/markdown
Requires-Dist: readchar
Provides-Extra: core
Requires-Dist: readchar; extra == "core"
Provides-Extra: prompts
Requires-Dist: readchar; extra == "prompts"
Provides-Extra: all
Requires-Dist: readchar; extra == "all"

<h1 align="center">
  pyclack
  <br>
  <img width="5%" align="center" src="https://img.shields.io/badge/prerelease-8FD28F" alt="logo">
  <img width="4%" align="center" src="https://img.shields.io/badge/python-blue" alt="logo">
</h1>


<p align="center">
  <b>Building interactive command line interfaces effortlessly.</b>
</p>

`/core`: This is your toolkit for building custom CLIs from scratch. It provides robust, unstyled components that give you complete creative freedom while handling all the complex functionality under the hood.

`/prompts`: Need something ready to use? This package offers a collection of beautifully designed prompts with an intuitive API. Just import and start using them - perfect when you want professional results without the custom styling work.

<div align="center">
    <kbd>
      <video width="100%" align="center" src="https://github.com/user-attachments/assets/07b959fb-165e-4419-93ba-74c235a7bc38" alt="demo /prompts">
    </kbd>
</div>


```

### pyclack_cli.egg-info\SOURCES.txt
- Size: 510.0 B
- Last Modified: 2024-12-09 13:48:48
- Created: 2024-12-09 13:48:08

#### Content:
```txt
README.md
setup.py
core/__init__.py
core/confirm.py
core/multiselect.py
core/password.py
core/prompt.py
core/select.py
core/select_key.py
core/spinner.py
core/text.py
prompts/__init__.py
prompts/confirm.py
prompts/mutliselect.py
prompts/password.py
prompts/select.py
prompts/spinner.py
prompts/text.py
pyclack_cli.egg-info/PKG-INFO
pyclack_cli.egg-info/SOURCES.txt
pyclack_cli.egg-info/dependency_links.txt
pyclack_cli.egg-info/requires.txt
pyclack_cli.egg-info/top_level.txt
utils/__init__.py
utils/styling.py
```

### pyclack_cli.egg-info\dependency_links.txt
- Size: 1.0 B
- Last Modified: 2024-12-09 13:48:48
- Created: 2024-12-09 13:48:08

#### Content:
```txt


```

### pyclack_cli.egg-info\requires.txt
- Size: 62.0 B
- Last Modified: 2024-12-09 13:48:48
- Created: 2024-12-09 13:48:08

#### Content:
```txt
readchar

[all]
readchar

[core]
readchar

[prompts]
readchar

```

### pyclack_cli.egg-info\top_level.txt
- Size: 19.0 B
- Last Modified: 2024-12-09 13:48:48
- Created: 2024-12-09 13:48:08

#### Content:
```txt
core
prompts
utils

```

### setup.py
- Size: 1.1 KB
- Last Modified: 2024-12-09 13:47:30
- Created: 2024-12-09 13:14:30

#### Content:
```py
from setuptools import setup, find_packages

base_requirements = ["readchar"]
core_requirements = base_requirements.copy()
prompts_requirements = base_requirements.copy()

setup(
    name="pyclack-cli",
    version="0.1.0",
    packages=find_packages(),
    python_requires=">=3.7",
    
    # core dependencies
    install_requires=base_requirements,
    # optional dependencies
    extras_require={
        "core": core_requirements,
        "prompts": prompts_requirements,
        "all": prompts_requirements,  # this includes everything
    },

    author="Edoardo Balducci",
    author_email="edoardoba2004@gmail.com",
    description="A python library for building interactive command line interfaces effortlessly. Inspired by clack.cc",
    long_description=open("README.md").read(),
    long_description_content_type="text/markdown",
    url="https://github.com/Bbalduzz/pyclack",
    classifiers=[
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
    ],
)
```

### utils\__init__.py
- Size: 0.0 B
- Last Modified: 2024-12-09 07:30:40
- Created: 2024-12-09 07:30:39

#### Content:
```py

```

### utils\styling.py
- Size: 4.2 KB
- Last Modified: 2024-12-09 07:29:43
- Created: 2024-12-09 07:29:41

#### Content:
```py
import sys
import re
import shutil
from typing import Any, List, Optional, Callable

def is_unicode_supported() -> bool:
    """Check if terminal supports Unicode characters."""
    try:
        return bool(sys.stdout.encoding.lower().startswith('utf'))
    except:
        return False

UNICODE = is_unicode_supported()

def s(unicode: str, fallback: str) -> str:
    """Select Unicode or fallback character based on terminal support."""
    return unicode if UNICODE else fallback

# Symbols
S_STEP_ACTIVE = s('◆', '*')
S_STEP_CANCEL = s('■', 'x')
S_STEP_ERROR = s('▲', 'x')
S_STEP_SUBMIT = s('◇', 'o')

S_BAR_START = s('┌', 'T')
S_BAR = s('│', '|')
S_BAR_END = s('└', '—')

S_RADIO_ACTIVE = s('●', '>')
S_RADIO_INACTIVE = s('○', ' ')
S_CHECKBOX_ACTIVE = s('◻', '[•]')
S_CHECKBOX_SELECTED = s('◼', '[+]')
S_CHECKBOX_INACTIVE = s('◻', '[ ]')
S_PASSWORD_MASK = s('▪', '•')

S_BAR_H = s('─', '-')
S_CORNER_TOP_RIGHT = s('╮', '+')
S_CONNECT_LEFT = s('├', '+')
S_CORNER_BOTTOM_RIGHT = s('╯', '+')

S_INFO = s('●', '•')
S_SUCCESS = s('◆', '*')
S_WARN = s('▲', '!')
S_ERROR = s('■', 'x')

class Color:
    """ANSI color and style utilities."""
    @staticmethod
    def gray(text: str) -> str:
        return f"\033[90m{text}\033[0m"
    
    @staticmethod
    def cyan(text: str) -> str:
        return f"\033[36m{text}\033[0m"
    
    @staticmethod
    def red(text: str) -> str:
        return f"\033[31m{text}\033[0m"
    
    @staticmethod
    def green(text: str) -> str:
        return f"\033[32m{text}\033[0m"
    
    @staticmethod
    def yellow(text: str) -> str:
        return f"\033[33m{text}\033[0m"
    
    @staticmethod
    def blue(text: str) -> str:
        return f"\033[34m{text}\033[0m"
    
    @staticmethod
    def magenta(text: str) -> str:
        return f"\033[35m{text}\033[0m"
    
    @staticmethod
    def dim(text: str) -> str:
        return f"\033[2m{text}\033[0m"
    
    @staticmethod
    def inverse(text: str) -> str:
        return f"\033[7m{text}\033[0m"
    
    @staticmethod
    def hidden(text: str) -> str:
        return f"\033[8m{text}\033[0m"
    
    @staticmethod
    def strikethrough(text: str) -> str:
        return f"\033[9m{text}\033[0m"
    
    @staticmethod
    def reset(text: str) -> str:
        return f"\033[0m{text}"

def strip_ansi(text: str) -> str:
    """Remove ANSI escape sequences from text."""
    ansi_pattern = r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])'
    return re.sub(ansi_pattern, '', text)

def symbol(state: str) -> str:
    """Get the appropriate symbol for the current state."""
    if state in ('initial', 'active'):
        return Color.cyan(S_STEP_ACTIVE)
    elif state == 'cancel':
        return Color.red(S_STEP_CANCEL)
    elif state == 'error':
        return Color.yellow(S_STEP_ERROR)
    elif state == 'submit':
        return Color.green(S_STEP_SUBMIT)
    return ''

def limit_options(options: List[Any], cursor: int, max_items: Optional[int] = None, 
                 style: Callable[[Any, bool], str] = lambda x, _: str(x)) -> List[str]:
    """Limit visible options based on terminal size and cursor position."""
    param_max_items = max_items or float('inf')
    output_max_items = max(shutil.get_terminal_size().lines - 4, 0)
    max_items = min(output_max_items, max(param_max_items, 5))
    
    window_start = 0
    if cursor >= window_start + max_items - 3:
        window_start = max(min(cursor - max_items + 3, len(options) - max_items), 0)
    elif cursor < window_start + 2:
        window_start = max(cursor - 2, 0)

    show_top_dots = max_items < len(options) and window_start > 0
    show_bottom_dots = (
        max_items < len(options) and 
        window_start + max_items < len(options)
    )

    visible_options = options[window_start:window_start + max_items]
    result = []

    for i, option in enumerate(visible_options):
        if (i == 0 and show_top_dots) or (i == len(visible_options) - 1 and show_bottom_dots):
            result.append(Color.dim('...'))
        else:
            result.append(style(option, i + window_start == cursor))

    return result
```

```

### dist\pyclack_cli-0.1.0-py3-none-any.whl
- Size: 18.4 KB
- Last Modified: 2024-12-09 13:48:50
- Created: 2024-12-09 13:48:50

#### Content:
```whl
[Binary file]
```

### dist\pyclack_cli-0.1.0.tar.gz
- Size: 12.5 KB
- Last Modified: 2024-12-09 13:48:48
- Created: 2024-12-09 13:48:48

#### Content:
```gz
[Binary file]
```

### docs.py
- Size: 5.2 KB
- Last Modified: 2024-12-09 13:57:14
- Created: 2024-12-09 13:54:18

#### Content:
```py
import os
from datetime import datetime
import argparse
from pathlib import Path

# Files and patterns to ignore
IGNORED_EXTENSIONS = {'pyc', 'pyo', 'pyd', 'class', 'o', 'so', 'dll', 'exe'}
IGNORED_PATTERNS = {
    '__pycache__',
    '.git',
    '.pytest_cache',
    'node_modules',
    'venv',
    '.env'
}

def should_ignore_file(path):
    """Check if the file or directory should be ignored"""
    # Check if any parent directory should be ignored
    parts = Path(path).parts
    if any(part in IGNORED_PATTERNS for part in parts):
        return True
        
    # Check file extension
    if path.suffix.lstrip('.') in IGNORED_EXTENSIONS:
        return True
            
    return False

def get_file_content(filepath):
    """Get the content of a file, handling binary files appropriately"""
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            return f.read()
    except (UnicodeDecodeError, IsADirectoryError):
        return "[Binary file]"
    except FileNotFoundError:
        return "[File not found]"
    except Exception as e:
        return f"[Error reading file: {str(e)}]"

def get_file_info(filepath):
    """Get file information including size and last modified time"""
    try:
        stats = os.stat(filepath)
        return {
            'size': stats.st_size,
            'modified': datetime.fromtimestamp(stats.st_mtime).strftime('%Y-%m-%d %H:%M:%S'),
            'created': datetime.fromtimestamp(stats.st_ctime).strftime('%Y-%m-%d %H:%M:%S')
        }
    except Exception as e:
        return {
            'size': 0,
            'modified': 'Unknown',
            'created': 'Unknown',
            'error': str(e)
        }

def scan_directory(directory):
    """Scan directory and return information about all files"""
    files_info = []
    
    for root, dirs, files in os.walk(directory):
        # Remove ignored directories
        dirs[:] = [d for d in dirs if d not in IGNORED_PATTERNS]
        
        for file in files:
            filepath = Path(root) / file
            if not should_ignore_file(filepath):
                files_info.append({
                    'path': str(filepath.relative_to(directory)),
                    'info': get_file_info(filepath),
                    'content': get_file_content(filepath)
                })
    
    return files_info

def format_size(size_in_bytes):
    """Format file size in human-readable format"""
    for unit in ['B', 'KB', 'MB', 'GB']:
        if size_in_bytes < 1024:
            return f"{size_in_bytes:.1f} {unit}"
        size_in_bytes /= 1024
    return f"{size_in_bytes:.1f} TB"

def generate_markdown_summary(directory, output_file='directory_docs.md'):
    """Generate a markdown file with directory contents summary"""
    files = scan_directory(directory)
    
    if not files:
        return "No files found."
    
    # Start with a header including timestamp
    markdown = [
        f"# Directory Documentation",
        f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        f"Base directory: {os.path.abspath(directory)}",
        "",
        "## Files Overview",
        "",
        "| File | Size | Last Modified | Created |",
        "|------|------|---------------|----------|"
    ]
    
    # Add files overview table
    for file_info in sorted(files, key=lambda x: x['path']):
        info = file_info['info']
        markdown.append(
            f"| {file_info['path']} | {format_size(info['size'])} | {info['modified']} | {info['created']} |"
        )
    
    # Add detailed file contents
    markdown.extend([
        "",
        "## Detailed Contents",
        ""
    ])
    
    for file_info in sorted(files, key=lambda x: x['path']):
        path = file_info['path']
        content = file_info['content']
        ext = os.path.splitext(path)[1].lstrip('.') or 'txt'
        
        markdown.extend([
            f"### {path}",
            f"- Size: {format_size(file_info['info']['size'])}",
            f"- Last Modified: {file_info['info']['modified']}",
            f"- Created: {file_info['info']['created']}",
            "",
            "#### Content:",
            f"```{ext}",
            content,
            "```",
            ""
        ])
    
    content = '\n'.join(markdown)
    
    # Write to file if output_file is provided
    if output_file:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(content)
        print(f"Documentation has been written to {output_file}")
    
    return content

def parse_arguments():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(description='Directory documentation generator')
    parser.add_argument(
        '-d', '--directory',
        default='.',
        help='Directory to document (default: current directory)'
    )
    parser.add_argument(
        '-o', '--output',
        default='directory_docs.md',
        help='Output file path (default: directory_docs.md)'
    )
    return parser.parse_args()

def main():
    args = parse_arguments()
    generate_markdown_summary(args.directory, args.output)

if __name__ == "__main__":
    main()
```

### main.py
- Size: 2.5 KB
- Last Modified: 2024-12-09 13:23:24
- Created: 2024-12-09 01:14:42

#### Content:
```py
from prompts import text, password, select, multiselect, confirm, create_note, note, intro, outro, Option, is_cancel
from prompts import *
import asyncio

async def simulate_install():
    """Simulate installation process with updates."""
    await asyncio.sleep(1)
    return "Installation complete!"

@with_spinner("Installing dependencies...")
async def install_deps():
    """Example of using spinner as a decorator."""
    await asyncio.sleep(2)
    return "Dependencies installed!"

async def main():
    # Intro
    intro("pyclack")
    
    # Project location
    project_path = await text(
        message="Where should we create your project?",
        placeholder=".",
        initial_value="."
    )
    if is_cancel(project_path):
        return
    
    pwd = await password(
        message = "Enter your secret",
        validate=lambda x: "password is too short" if len(x) < 5 else None
    )
    if is_cancel(pwd):
        return
    
    # Project type
    project_type = await select(
        message=f'Pick a project type within "{project_path}"',
        options=[
            Option("typescript", "TypeScript"),
            Option("javascript", "JavaScript")
        ],
        initial_value="typescript"
    )
    if is_cancel(project_type):
        return
    
    # Tools selection
    tools = await multiselect(
        message="Select additional tools.",
        options=[
            Option("prettier", "Prettier"),
            Option("eslint", "ESLint"),
            Option("jest", "Jest")
        ],
        initial_values=["prettier", "eslint"]
    )
    if is_cancel(tools):
        return
    
    # Install dependencies
    install = await confirm(
        message="Install dependencies?",
        active="Yes",
        inactive="No",
        initial_value=True
    )
    if is_cancel(install):
        return

    if install:
        # Method 1: Using context manager
        async with spinner("Setting up project...") as spin:
            await asyncio.sleep(1)
            spin.update("Installing packages...")
            await asyncio.sleep(1)
            spin.update("Configuring tools...")
            await asyncio.sleep(1)
            spin.update("Dependencies installed!")

        # Method 2: Using decorated function
        # await install_deps()
    
    # Next steps
    steps = [
        "cd .",
        "pnpm dev"
    ]
    
    note(title="Next steps.", next_steps=steps)
    outro(f"{Color.dim(f'Problems? {link(url='https://github.com/Bbalduzz/pyclack')}')}")

if __name__ == "__main__":
    asyncio.run(main())
```

### prompts\__init__.py
- Size: 2.9 KB
- Last Modified: 2024-12-09 13:09:55
- Created: 2024-12-09 13:03:27

#### Content:
```py
from .text import text
from .password import password
from .select import select
from .mutliselect import multiselect
from .confirm import confirm
from .spinner import spinner, with_spinner
from core import Option, is_cancel
from utils.styling import Color, strip_ansi, S_BAR, S_STEP_SUBMIT, S_CORNER_TOP_RIGHT, S_BAR_H, S_CONNECT_LEFT, S_CORNER_BOTTOM_RIGHT, S_BAR_START, S_BAR_END

def create_note(message: str = '', title: str = '') -> str:
    lines = f"\n{message}\n".split('\n')
    title_len = len(strip_ansi(title))
    max_len = max(
        max(len(strip_ansi(ln)) for ln in lines),
        title_len
    ) + 2

    formatted_lines = [
        f"{Color.gray(S_BAR)}  {Color.dim(ln)}{' ' * (max_len - len(strip_ansi(ln)))}{Color.gray(S_BAR)}"
        for ln in lines
    ]
    
    note_display = "\n".join(formatted_lines)
    
    return (
        f"{Color.gray(S_BAR)}\n"
        f"{Color.reset(S_STEP_SUBMIT)}  {Color.reset(title)} {Color.gray(S_BAR_H * max(max_len - title_len - 1, 1))}{Color.gray(S_CORNER_TOP_RIGHT)}\n"
        f"{note_display}\n"
        f"{Color.gray(S_CONNECT_LEFT)}{Color.gray(S_BAR_H * (max_len + 2))}{Color.gray(S_CORNER_BOTTOM_RIGHT)}\n"
    )

def note(message: str = None, title: str = '', next_steps: list = []) -> str:
    print(create_note(
        message=message if message else '\n'.join(next_steps),
        title=title if title else "Next steps."
    ))

def intro(title: str = '', options=None) -> None:
    """Display intro with optional title and styling.
    
    Args:
        title: Optional title text
        options: Dict with 'color' styling (defaults to gray)
    """
    if options is None:
        options = {"color": Color.gray}
    
    color = options.get('color', Color.gray)
    print("\033[H\033[J")  # Clear screen
    print(f"{color(S_BAR_START)}  {title}")

def outro(message: str = '', options=None) -> None:
    """Display outro with optional message and styling.
    
    Args:
        message: Optional message text
        options: Dict with 'color' styling (defaults to gray) 
    """
    if options is None:
        options = {"color": Color.gray}
    
    color = options.get('color', Color.gray)
    print(f"{color(S_BAR)}\n{color(S_BAR_END)}  {message}\n")

def link(url, label=None, options=None):
    """Generate a terminal hyperlink with optional styling.
    
    Args:
        url: The URL to link to
        label: Optional text to display (defaults to URL if None)
        options: Dict with 'color' and 'bg_color' keys for styling
    """
    if options is None:
        options = {"color": Color.cyan, "bg_color": None}
    
    label = label or url
    color = options.get('color')
    
    # Build link with color function applied to the whole link if color exists
    link = f"\033]8;;{url}\033\\{label}\033]8;;\033\\"
    return color(link) if color else link
```

### prompts\confirm.py
- Size: 1.7 KB
- Last Modified: 2024-12-09 13:08:29
- Created: 2024-12-09 12:56:16

#### Content:
```py
from typing import Union, Any
from core import ConfirmPrompt, is_cancel
from utils.styling import (
    Color, symbol, S_BAR, S_BAR_END, S_RADIO_ACTIVE, S_RADIO_INACTIVE
)

async def confirm(
    message: str,
    active: str = "Yes",
    inactive: str = "No",
    initial_value: bool = True
) -> Union[bool, object]:
    def render(prompt: ConfirmPrompt) -> str:
        title = f"{Color.gray(S_BAR)}\n{symbol(prompt.state)}  {message}\n"
        value = active if prompt.value else inactive

        if prompt.state == 'submit':
            return f"{title}"
        elif prompt.state == 'cancel':
            return (f"{title}{Color.gray(S_BAR)}  "
                   f"{Color.strikethrough(Color.dim(value))}\n"
                   f"{Color.gray(S_BAR)}")
        else:
            active_style = (
                f"{Color.green(S_RADIO_ACTIVE)} {active}"
                if prompt.value else
                f"{Color.dim(S_RADIO_INACTIVE)} {Color.dim(active)}"
            )
            inactive_style = (
                f"{Color.green(S_RADIO_ACTIVE)} {inactive}"
                if not prompt.value else
                f"{Color.dim(S_RADIO_INACTIVE)} {Color.dim(inactive)}"
            )
            return (f"{title}{Color.cyan(S_BAR)}  "
                   f"{active_style} {Color.dim('/')} {inactive_style}\n"
                   f"{Color.cyan(S_BAR_END)}\n")

    prompt = ConfirmPrompt(
        render=render,
        active=active,
        inactive=inactive,
        initial_value=initial_value
    )
    result = await prompt.prompt()
    
    if is_cancel(result):
        return result
    
    print(f"{Color.gray(S_BAR)}  {Color.dim(result)}")
    return result

```

### prompts\mutliselect.py
- Size: 4.4 KB
- Last Modified: 2024-12-09 15:27:43
- Created: 2024-12-09 12:59:11

#### Content:
```py
from typing import List, Any, Optional, Union, Any
from core import MultiSelectPrompt, Option, is_cancel
from utils.styling import Color, symbol, limit_options, S_BAR, S_BAR_END, S_CHECKBOX_ACTIVE, S_CHECKBOX_SELECTED, S_CHECKBOX_INACTIVE

async def multiselect(
    message: str,
    options: List[Option],
    initial_values: List[Any] = None,
    max_items: Optional[int] = None,
    required: bool = True,
    cursor_at: Any = None
) -> Union[List[Any], object]:
    
    def render(prompt: MultiSelectPrompt) -> str:
        def opt(option: Option, state: str) -> str:
            label = option.label or str(option.value)
            if state == 'active':
                return (f"{Color.cyan(S_CHECKBOX_ACTIVE)} {label} "
                    f"{option.hint and Color.dim(f'({option.hint})') or ''}")
            elif state == 'selected':
                return f"{Color.green(S_CHECKBOX_SELECTED)} {Color.dim(label)}"
            elif state == 'cancelled':
                return Color.strikethrough(Color.dim(label))
            elif state == 'active-selected':
                return (f"{Color.green(S_CHECKBOX_SELECTED)} {label} "
                    f"{option.hint and Color.dim(f'({option.hint})') or ''}")
            elif state == 'submitted':
                return Color.dim(label)
            return f"{Color.dim(S_CHECKBOX_INACTIVE)} {Color.dim(label)}"

        title = f"{Color.gray(S_BAR)}\n{symbol(prompt.state)}  {message}\n"

        if prompt.state == 'submit':
            selected = [opt for opt in prompt.options if opt.value in prompt.value]
            selected_labels = [opt.label for opt in selected]
            return (f"{Color.gray(S_BAR)}\n"
                f"{symbol(prompt.state)}  {message}\n")

        if prompt.state == 'cancel':
            styled_options = limit_options(
                options=prompt.options,
                cursor=prompt.cursor,
                max_items=max_items,
                style=lambda item, active: opt(
                    item,
                    'cancelled' if item.value in prompt.value else 'inactive'
                )
            )
            return (f"{title}{Color.red(S_BAR)}  "
                f"{f'\n{Color.red(S_BAR)}  '.join(styled_options)}\n"
                f"{Color.red(S_BAR_END)}  {Color.red('Operation cancelled')}\n")
        elif prompt.state == 'error':
            footer = prompt.error.split('\n')
            footer = [
                f"{Color.yellow(S_BAR_END)}  {Color.yellow(footer[0])}",
                *[f"   {line}" for line in footer[1:]]
            ]
            styled_options = limit_options(
                options=prompt.options,
                cursor=prompt.cursor,
                max_items=max_items,
                style=lambda item, active: opt(
                    item,
                    'active-selected' if active and item.value in prompt.value
                    else 'selected' if item.value in prompt.value
                    else 'active' if active
                    else 'inactive'
                )
            )
            return (f"{title}{Color.yellow(S_BAR)}  "
                f"{f'\n{Color.yellow(S_BAR)}  '.join(styled_options)}\n"
                f"{'\n'.join(footer)}\n")
        else:
            styled_options = limit_options(
                options=prompt.options,
                cursor=prompt.cursor,
                max_items=max_items,
                style=lambda item, active: opt(
                    item,
                    'active-selected' if active and item.value in prompt.value
                    else 'selected' if item.value in prompt.value
                    else 'active' if active
                    else 'inactive'
                )
            )
            return (f"{title}{Color.cyan(S_BAR)}  "
                f"{f'\n{Color.cyan(S_BAR)}  '.join(styled_options)}\n"
                f"{Color.cyan(S_BAR_END)}\n")

    prompt = MultiSelectPrompt(
        render=render,
        options=options,
        initial_values=initial_values,
        required=required,
        cursor_at=cursor_at,
        debug=False
    )
    result = await prompt.prompt()
    
    if is_cancel(result):
        return result
    
    # Print final state
    selected = [opt for opt in options if opt.value in result]
    print(f"{Color.gray(S_BAR)}  {Color.dim(', '.join(opt.label for opt in selected))}")
    
    return result
```

### prompts\password.py
- Size: 1.4 KB
- Last Modified: 2024-12-09 15:28:10
- Created: 2024-12-09 12:55:42

#### Content:
```py
from typing import Callable, Optional, Union
from core import PasswordPrompt, is_cancel
from utils.styling import Color, symbol, S_BAR, S_BAR_END, S_PASSWORD_MASK

async def password(
    message: str,
    mask: str = S_PASSWORD_MASK,
    validate: Optional[Callable[[str], Optional[str]]] = None
) -> Union[str, object]:
    def render(prompt: PasswordPrompt) -> str:
        title = f"{Color.gray(S_BAR)}\n{symbol(prompt.state)}  {message}\n"
        value = prompt.value_with_cursor
        masked = prompt.masked

        if prompt.state == 'error':
            return (f"{title.rstrip()}\n"
                   f"{Color.yellow(S_BAR)}  {masked}\n"
                   f"{Color.yellow(S_BAR_END)}  {Color.yellow(prompt.error)}\n")
        elif prompt.state == 'submit':
            return f"{title}"
        elif prompt.state == 'cancel':
            return (f"{title.rstrip()}\n"
                   f"{Color.red(S_BAR)}  {masked}\n"
                   f"{Color.red(S_BAR_END)}  {Color.red('Operation cancelled')}\n")
        else:
            return f"{title}{Color.cyan(S_BAR)}  {value}\n{Color.cyan(S_BAR_END)}\n"

    prompt = PasswordPrompt(render=render, mask=mask, validate=validate)
    result = await prompt.prompt()
    
    if is_cancel(result):
        return result

    print(f"{Color.gray(S_BAR)}  {Color.dim(S_PASSWORD_MASK * len(result))}")
    return result
```

### prompts\select.py
- Size: 2.4 KB
- Last Modified: 2024-12-09 15:28:40
- Created: 2024-12-09 12:57:22

#### Content:
```py
from typing import List, Any, Optional, Union, Any
from core import SelectPrompt, Option, is_cancel
from utils.styling import Color, symbol, limit_options, S_BAR, S_BAR_END, S_RADIO_ACTIVE, S_RADIO_INACTIVE

async def select(
    message: str,
    options: List[Option],
    initial_value: Any = None,
    max_items: Optional[int] = None
) -> Union[Any, object]:
    def opt(option: Option, state: str) -> str:
        label = option.label or str(option.value)
        if state == 'selected':
            return Color.dim(label)
        elif state == 'active':
            return (f"{Color.green(S_RADIO_ACTIVE)} {label} "
                   f"{option.hint and Color.dim(f'({option.hint})') or ''}")
        elif state == 'cancelled':
            return Color.strikethrough(Color.dim(label))
        else:
            return f"{Color.dim(S_RADIO_INACTIVE)} {Color.dim(label)}"

    def render(prompt: SelectPrompt) -> str:
        title = f"{Color.gray(S_BAR)}\n{symbol(prompt.state)}  {message}\n"

        if prompt.state == 'submit':
            return f"{title}"
        elif prompt.state == 'cancel':
            styled_options = limit_options(
                options=prompt.options,
                cursor=prompt.cursor,
                max_items=max_items,
                style=lambda item, active: opt(item, 'cancelled')
            )
            return (f"{title}{Color.red(S_BAR)}  "
                f"{f'\n{Color.red(S_BAR)}  '.join(styled_options)}\n"
                f"{Color.red(S_BAR_END)}  {Color.red('Operation cancelled')}\n")
        else:
            styled_options = limit_options(
                options=prompt.options,
                cursor=prompt.cursor,
                max_items=max_items,
                style=lambda item, active: opt(item, 'active' if active else 'inactive')
            )
            return (f"{title}{Color.cyan(S_BAR)}  "
                f"{f'\n{Color.cyan(S_BAR)}  '.join(styled_options)}\n"
                f"{Color.cyan(S_BAR_END)}\n")

    prompt = SelectPrompt(
        render=render,
        options=options,
        initial_value=initial_value
    )
    result = await prompt.prompt()
    
    if is_cancel(result):
        return result
        
    selected_option = next((opt for opt in options if opt.value == result), None)
    if selected_option:
        print(f"{Color.gray(S_BAR)}  {Color.dim(selected_option.label)}")
    return result
```

### prompts\spinner.py
- Size: 1.4 KB
- Last Modified: 2024-12-09 15:32:00
- Created: 2024-12-09 13:02:14

#### Content:
```py
from contextlib import asynccontextmanager
from functools import wraps
from core import Spinner
from utils.styling import Color

@asynccontextmanager
async def spinner(message: str = '', options=None):
    """Async context manager for showing a loading spinner.
    
    Args:
        message: Message to display next to spinner
        options: Dict with 'color' styling (defaults to magenta for spinner)
    
    Usage:
        async with spinner("Loading..."):
            await some_async_operation()
    """
    if options is None:
        options = {"color": Color.magenta}
        
    spin = Spinner()
    try:
        spin.start(message)
        yield spin
    finally:
        spin.stop()

def with_spinner(message: str = ''):
    """Decorator to add a spinner to an async function.
    
    Args:
        message: Message to display next to spinner
    
    Usage:
        @with_spinner("Loading...")
        async def my_function():
            await some_async_operation()
    """
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            async with spinner(message) as spin:
                try:
                    result = await func(*args, **kwargs)
                    return result
                except Exception as e:
                    spin.stop(str(e), code=2)
                    raise
        return wrapper
    return decorator

```

### prompts\text.py
- Size: 1.8 KB
- Last Modified: 2024-12-09 15:32:31
- Created: 2024-12-09 12:54:02

#### Content:
```py
from typing import Callable, Optional, Union, Any
from core import TextPrompt, is_cancel
from utils.styling import Color, symbol, S_BAR, S_BAR_END

async def text(
    message: str,
    placeholder: str = '',
    default_value: str = '',
    initial_value: str = '',
    validate: Optional[Callable[[str], Optional[str]]] = None
) -> Union[str, object]:
    def render(prompt: TextPrompt) -> str:
        title = f"{Color.gray(S_BAR)}\n{symbol(prompt.state)}  {message}\n"
        placeholder_text = (
            Color.inverse(placeholder[0]) + Color.dim(placeholder[1:])
            if placeholder else Color.inverse(Color.hidden('_'))
        )
        value = placeholder_text if not prompt.value else prompt.value_with_cursor

        if prompt.state == 'error':
            return (f"{title.rstrip()}\n"
                   f"{Color.yellow(S_BAR)}  {value}\n"
                   f"{Color.yellow(S_BAR_END)}  {Color.yellow(prompt.error)}\n")
        elif prompt.state == 'submit':
            return (f"{Color.gray(S_BAR)}\n"
                   f"{symbol(prompt.state)}  {message}\n")
        elif prompt.state == 'cancel':
            return (f"{title.rstrip()}\n"
                   f"{Color.red(S_BAR)}  {Color.dim(prompt.value) if prompt.value else placeholder_text}\n"
                   f"{Color.red(S_BAR_END)}  {Color.red('Operation cancelled')}\n")
        else:
            return f"{title}{Color.cyan(S_BAR)}  {value}\n{Color.cyan(S_BAR_END)}\n"

    prompt = TextPrompt(
        render=render,
        placeholder=placeholder,
        initial_value=initial_value,
        default_value=default_value,
        validate=validate
    )
    result = await prompt.prompt()
    
    if is_cancel(result):
        return result
        
    print(f"{Color.gray(S_BAR)}  {Color.dim(result)}")
    return result
```

### pyclack.egg-info\PKG-INFO
- Size: 1.7 KB
- Last Modified: 2024-12-09 13:24:42
- Created: 2024-12-09 13:24:42

#### Content:
```txt
Metadata-Version: 2.1
Name: pyclack
Version: 0.1.0
Summary: A python library for building interactive command line interfaces effortlessly. Inspired by clack.cc
Home-page: https://github.com/Bbalduzz/pyclack
Author: Edoardo Balducci
Author-email: edoardoba2004@gmail.com
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Requires-Python: >=3.7
Description-Content-Type: text/markdown
Requires-Dist: readchar
Provides-Extra: core
Requires-Dist: readchar; extra == "core"
Provides-Extra: prompts
Requires-Dist: readchar; extra == "prompts"
Provides-Extra: all
Requires-Dist: readchar; extra == "all"

<h1 align="center">
  pyclack
  <br>
  <img width="5%" align="center" src="https://img.shields.io/badge/prerelease-8FD28F" alt="logo">
  <img width="4%" align="center" src="https://img.shields.io/badge/python-blue" alt="logo">
</h1>


<p align="center">
  <b>Building interactive command line interfaces effortlessly.</b>
</p>

`/core`: This is your toolkit for building custom CLIs from scratch. It provides robust, unstyled components that give you complete creative freedom while handling all the complex functionality under the hood.

`/prompts`: Need something ready to use? This package offers a collection of beautifully designed prompts with an intuitive API. Just import and start using them - perfect when you want professional results without the custom styling work.

<div align="center">
    <kbd>
      <video width="100%" align="center" src="https://github.com/user-attachments/assets/07b959fb-165e-4419-93ba-74c235a7bc38" alt="demo /prompts">
    </kbd>
</div>


```

### pyclack.egg-info\SOURCES.txt
- Size: 490.0 B
- Last Modified: 2024-12-09 13:24:42
- Created: 2024-12-09 13:24:42

#### Content:
```txt
README.md
setup.py
core/__init__.py
core/confirm.py
core/multiselect.py
core/password.py
core/prompt.py
core/select.py
core/select_key.py
core/spinner.py
core/text.py
prompts/__init__.py
prompts/confirm.py
prompts/mutliselect.py
prompts/password.py
prompts/select.py
prompts/spinner.py
prompts/text.py
pyclack.egg-info/PKG-INFO
pyclack.egg-info/SOURCES.txt
pyclack.egg-info/dependency_links.txt
pyclack.egg-info/requires.txt
pyclack.egg-info/top_level.txt
utils/__init__.py
utils/styling.py
```

### pyclack.egg-info\dependency_links.txt
- Size: 1.0 B
- Last Modified: 2024-12-09 13:24:42
- Created: 2024-12-09 13:24:42

#### Content:
```txt


```

### pyclack.egg-info\requires.txt
- Size: 62.0 B
- Last Modified: 2024-12-09 13:24:42
- Created: 2024-12-09 13:24:42

#### Content:
```txt
readchar

[all]
readchar

[core]
readchar

[prompts]
readchar

```

### pyclack.egg-info\top_level.txt
- Size: 19.0 B
- Last Modified: 2024-12-09 13:24:42
- Created: 2024-12-09 13:24:42

#### Content:
```txt
core
prompts
utils

```

### pyclack_cli.egg-info\PKG-INFO
- Size: 1.7 KB
- Last Modified: 2024-12-09 13:48:48
- Created: 2024-12-09 13:48:48

#### Content:
```txt
Metadata-Version: 2.1
Name: pyclack-cli
Version: 0.1.0
Summary: A python library for building interactive command line interfaces effortlessly. Inspired by clack.cc
Home-page: https://github.com/Bbalduzz/pyclack
Author: Edoardo Balducci
Author-email: edoardoba2004@gmail.com
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Requires-Python: >=3.7
Description-Content-Type: text/markdown
Requires-Dist: readchar
Provides-Extra: core
Requires-Dist: readchar; extra == "core"
Provides-Extra: prompts
Requires-Dist: readchar; extra == "prompts"
Provides-Extra: all
Requires-Dist: readchar; extra == "all"

<h1 align="center">
  pyclack
  <br>
  <img width="5%" align="center" src="https://img.shields.io/badge/prerelease-8FD28F" alt="logo">
  <img width="4%" align="center" src="https://img.shields.io/badge/python-blue" alt="logo">
</h1>


<p align="center">
  <b>Building interactive command line interfaces effortlessly.</b>
</p>

`/core`: This is your toolkit for building custom CLIs from scratch. It provides robust, unstyled components that give you complete creative freedom while handling all the complex functionality under the hood.

`/prompts`: Need something ready to use? This package offers a collection of beautifully designed prompts with an intuitive API. Just import and start using them - perfect when you want professional results without the custom styling work.

<div align="center">
    <kbd>
      <video width="100%" align="center" src="https://github.com/user-attachments/assets/07b959fb-165e-4419-93ba-74c235a7bc38" alt="demo /prompts">
    </kbd>
</div>


```

### pyclack_cli.egg-info\SOURCES.txt
- Size: 510.0 B
- Last Modified: 2024-12-09 13:48:48
- Created: 2024-12-09 13:48:08

#### Content:
```txt
README.md
setup.py
core/__init__.py
core/confirm.py
core/multiselect.py
core/password.py
core/prompt.py
core/select.py
core/select_key.py
core/spinner.py
core/text.py
prompts/__init__.py
prompts/confirm.py
prompts/mutliselect.py
prompts/password.py
prompts/select.py
prompts/spinner.py
prompts/text.py
pyclack_cli.egg-info/PKG-INFO
pyclack_cli.egg-info/SOURCES.txt
pyclack_cli.egg-info/dependency_links.txt
pyclack_cli.egg-info/requires.txt
pyclack_cli.egg-info/top_level.txt
utils/__init__.py
utils/styling.py
```

### pyclack_cli.egg-info\dependency_links.txt
- Size: 1.0 B
- Last Modified: 2024-12-09 13:48:48
- Created: 2024-12-09 13:48:08

#### Content:
```txt


```

### pyclack_cli.egg-info\requires.txt
- Size: 62.0 B
- Last Modified: 2024-12-09 13:48:48
- Created: 2024-12-09 13:48:08

#### Content:
```txt
readchar

[all]
readchar

[core]
readchar

[prompts]
readchar

```

### pyclack_cli.egg-info\top_level.txt
- Size: 19.0 B
- Last Modified: 2024-12-09 13:48:48
- Created: 2024-12-09 13:48:08

#### Content:
```txt
core
prompts
utils

```

### setup.py
- Size: 1.1 KB
- Last Modified: 2024-12-09 13:47:30
- Created: 2024-12-09 13:14:30

#### Content:
```py
from setuptools import setup, find_packages

base_requirements = ["readchar"]
core_requirements = base_requirements.copy()
prompts_requirements = base_requirements.copy()

setup(
    name="pyclack-cli",
    version="0.1.0",
    packages=find_packages(),
    python_requires=">=3.7",
    
    # core dependencies
    install_requires=base_requirements,
    # optional dependencies
    extras_require={
        "core": core_requirements,
        "prompts": prompts_requirements,
        "all": prompts_requirements,  # this includes everything
    },

    author="Edoardo Balducci",
    author_email="edoardoba2004@gmail.com",
    description="A python library for building interactive command line interfaces effortlessly. Inspired by clack.cc",
    long_description=open("README.md").read(),
    long_description_content_type="text/markdown",
    url="https://github.com/Bbalduzz/pyclack",
    classifiers=[
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
    ],
)
```

### utils\__init__.py
- Size: 0.0 B
- Last Modified: 2024-12-09 07:30:40
- Created: 2024-12-09 07:30:39

#### Content:
```py

```

### utils\styling.py
- Size: 4.2 KB
- Last Modified: 2024-12-09 07:29:43
- Created: 2024-12-09 07:29:41

#### Content:
```py
import sys
import re
import shutil
from typing import Any, List, Optional, Callable

def is_unicode_supported() -> bool:
    """Check if terminal supports Unicode characters."""
    try:
        return bool(sys.stdout.encoding.lower().startswith('utf'))
    except:
        return False

UNICODE = is_unicode_supported()

def s(unicode: str, fallback: str) -> str:
    """Select Unicode or fallback character based on terminal support."""
    return unicode if UNICODE else fallback

# Symbols
S_STEP_ACTIVE = s('◆', '*')
S_STEP_CANCEL = s('■', 'x')
S_STEP_ERROR = s('▲', 'x')
S_STEP_SUBMIT = s('◇', 'o')

S_BAR_START = s('┌', 'T')
S_BAR = s('│', '|')
S_BAR_END = s('└', '—')

S_RADIO_ACTIVE = s('●', '>')
S_RADIO_INACTIVE = s('○', ' ')
S_CHECKBOX_ACTIVE = s('◻', '[•]')
S_CHECKBOX_SELECTED = s('◼', '[+]')
S_CHECKBOX_INACTIVE = s('◻', '[ ]')
S_PASSWORD_MASK = s('▪', '•')

S_BAR_H = s('─', '-')
S_CORNER_TOP_RIGHT = s('╮', '+')
S_CONNECT_LEFT = s('├', '+')
S_CORNER_BOTTOM_RIGHT = s('╯', '+')

S_INFO = s('●', '•')
S_SUCCESS = s('◆', '*')
S_WARN = s('▲', '!')
S_ERROR = s('■', 'x')

class Color:
    """ANSI color and style utilities."""
    @staticmethod
    def gray(text: str) -> str:
        return f"\033[90m{text}\033[0m"
    
    @staticmethod
    def cyan(text: str) -> str:
        return f"\033[36m{text}\033[0m"
    
    @staticmethod
    def red(text: str) -> str:
        return f"\033[31m{text}\033[0m"
    
    @staticmethod
    def green(text: str) -> str:
        return f"\033[32m{text}\033[0m"
    
    @staticmethod
    def yellow(text: str) -> str:
        return f"\033[33m{text}\033[0m"
    
    @staticmethod
    def blue(text: str) -> str:
        return f"\033[34m{text}\033[0m"
    
    @staticmethod
    def magenta(text: str) -> str:
        return f"\033[35m{text}\033[0m"
    
    @staticmethod
    def dim(text: str) -> str:
        return f"\033[2m{text}\033[0m"
    
    @staticmethod
    def inverse(text: str) -> str:
        return f"\033[7m{text}\033[0m"
    
    @staticmethod
    def hidden(text: str) -> str:
        return f"\033[8m{text}\033[0m"
    
    @staticmethod
    def strikethrough(text: str) -> str:
        return f"\033[9m{text}\033[0m"
    
    @staticmethod
    def reset(text: str) -> str:
        return f"\033[0m{text}"

def strip_ansi(text: str) -> str:
    """Remove ANSI escape sequences from text."""
    ansi_pattern = r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])'
    return re.sub(ansi_pattern, '', text)

def symbol(state: str) -> str:
    """Get the appropriate symbol for the current state."""
    if state in ('initial', 'active'):
        return Color.cyan(S_STEP_ACTIVE)
    elif state == 'cancel':
        return Color.red(S_STEP_CANCEL)
    elif state == 'error':
        return Color.yellow(S_STEP_ERROR)
    elif state == 'submit':
        return Color.green(S_STEP_SUBMIT)
    return ''

def limit_options(options: List[Any], cursor: int, max_items: Optional[int] = None, 
                 style: Callable[[Any, bool], str] = lambda x, _: str(x)) -> List[str]:
    """Limit visible options based on terminal size and cursor position."""
    param_max_items = max_items or float('inf')
    output_max_items = max(shutil.get_terminal_size().lines - 4, 0)
    max_items = min(output_max_items, max(param_max_items, 5))
    
    window_start = 0
    if cursor >= window_start + max_items - 3:
        window_start = max(min(cursor - max_items + 3, len(options) - max_items), 0)
    elif cursor < window_start + 2:
        window_start = max(cursor - 2, 0)

    show_top_dots = max_items < len(options) and window_start > 0
    show_bottom_dots = (
        max_items < len(options) and 
        window_start + max_items < len(options)
    )

    visible_options = options[window_start:window_start + max_items]
    result = []

    for i, option in enumerate(visible_options):
        if (i == 0 and show_top_dots) or (i == len(visible_options) - 1 and show_bottom_dots):
            result.append(Color.dim('...'))
        else:
            result.append(style(option, i + window_start == cursor))

    return result
```
